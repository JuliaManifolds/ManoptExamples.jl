<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Elastic Geodesic under force field · ManoptExamples.jl</title><meta name="title" content="Elastic Geodesic under force field · ManoptExamples.jl"/><meta property="og:title" content="Elastic Geodesic under force field · ManoptExamples.jl"/><meta property="twitter:title" content="Elastic Geodesic under force field · ManoptExamples.jl"/><meta name="description" content="Documentation for ManoptExamples.jl."/><meta property="og:description" content="Documentation for ManoptExamples.jl."/><meta property="twitter:description" content="Documentation for ManoptExamples.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ManoptExamples.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Difference of Convex</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Difference-of-Convex-Benchmark/">A Benchmark</a></li><li><a class="tocitem" href="../Difference-of-Convex-Rosenbrock/">Rosenbrock Metric</a></li><li><a class="tocitem" href="../Difference-of-Convex-Frank-Wolfe/">Frank Wolfe comparison</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Convex Bundle Method</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../RCBM-Median/">Riemannian Median</a></li><li><a class="tocitem" href="../H2-Signal-TV/">Hyperbolic Signal Denoising</a></li><li><a class="tocitem" href="../Spectral-Procrustes/">Spectral Procrustes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">LTMADS</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Spectral-Procrustes-2D/">Spectral &amp; Robust Procrustes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Projected Gradient Algorithm</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Constrained-Mean-H2/">Mean on <span>$\mathbb H^2$</span></a></li><li><a class="tocitem" href="../Constrained-Mean-Hn/">Mean on <span>$\mathbb H^n$</span></a></li></ul></li><li><a class="tocitem" href="../HyperparameterOptimization/">Hyperparameter optimziation</a></li><li><a class="tocitem" href="../RayleighQuotient/">The Rayleigh Quotient</a></li><li><a class="tocitem" href="../Riemannian-mean/">Riemannian Mean</a></li><li><input class="collapse-toggle" id="menuitem-2-9" type="checkbox"/><label class="tocitem" for="menuitem-2-9"><span class="docs-label">Proximal Gradient Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../NCRPG-Sparse-PCA/">Sparse PCA</a></li><li><a class="tocitem" href="../NCRPG-Grassmann/">Grassmann Experiment</a></li><li><a class="tocitem" href="../NCRPG-Row-Sparse-Low-Rank/">Row-Sparse Low-Rank Matrix Recovery</a></li><li><a class="tocitem" href="../CRPG-Convex-SPD/">Convex Example on SPDs</a></li><li><a class="tocitem" href="../CRPG-Sparse-Approximation/">Sparse Approximation on <span>$\mathbb H^n$</span></a></li><li><a class="tocitem" href="../CRPG-Constrained-Mean-Hn/">Mean on <span>$\mathbb H^n$</span></a></li></ul></li><li><a class="tocitem" href="../Robust-PCA/">Robust PCA</a></li><li><a class="tocitem" href="../Rosenbrock/">Rosenbrock</a></li><li><a class="tocitem" href="../Total-Variation/">Total Variation</a></li><li><input class="collapse-toggle" id="menuitem-2-13" type="checkbox" checked/><label class="tocitem" for="menuitem-2-13"><span class="docs-label">Vector bundle Newton</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Elastic Geodesic under force field</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Newton-Equation"><span>Newton Equation</span></a></li><li><a class="tocitem" href="#Technical-details"><span>Technical details</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../Elastic-Geodesic-Obstacle/">Elastic Geodesic Obstacle</a></li><li><a class="tocitem" href="../Inextensible-Rod/">Inextensible Rod</a></li></ul></li></ul></li><li><a class="tocitem" href="../../objectives/">Objectives</a></li><li><a class="tocitem" href="../../data/">Data</a></li><li><a class="tocitem" href="../../contributing/">Contributing to ManoptExamples.jl</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Vector bundle Newton</a></li><li class="is-active"><a href>Elastic Geodesic under force field</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Elastic Geodesic under force field</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManoptExamples.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/main/docs/src/examples/Elastic-Geodesic-under-forcefield.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Elastic-Geodesic-under-Force-Field-on-the-Sphere"><a class="docs-heading-anchor" href="#Elastic-Geodesic-under-Force-Field-on-the-Sphere">Elastic Geodesic under Force Field on the Sphere</a><a id="Elastic-Geodesic-under-Force-Field-on-the-Sphere-1"></a><a class="docs-heading-anchor-permalink" href="#Elastic-Geodesic-under-Force-Field-on-the-Sphere" title="Permalink"></a></h1><p>Laura Weigl, Ronny Bergmann, and Anton Schiela 2025-11-25</p><pre><code class="language-julia hljs">using LinearAlgebra, SparseArrays, OffsetArrays
using Manifolds, Manopt, ManoptExamples
using GLMakie, Makie, GeometryTypes, Colors, ColorSchemes, NamedColors
using CSV, DataFrames</code></pre><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>In this example we compute an elastic geodesic under a force field on the sphere by applying Newton’s method on vector bundles which was introduced in [<a href="../../references/#WeiglBergmannSchiela_2025">WBS25</a>]. This example reproduces the results from the example in Section 6.1 therein.</p><p>We consider the sphere <span>$\mathbb{S}^2$</span> equipped with the Riemannian metric <span>$⟨  ⋅ ,  ⋅  ⟩$</span> given by the Euclidean inner product with corresponding norm <span>$\lVert ⋅ \rVert$</span> and an interval <span>$I = [0,T] ⊂ \mathbb R$</span>. Let <span>$\mathcal X = H^1(I, \mathbb S^2)$</span> and <span>$\mathcal E^* = T^*\mathcal X$</span> its cotangent bundle.</p><p>Our goal is to find a zero of the mapping <span>$F: \mathcal X → \mathcal E^*$</span> with</p><p class="math-container">\[F(γ)ϕ := \int_I ⟨\dot{γ}(t), \dot{ϕ}(t)⟩ + ω(γ(t))ϕ(t) \; \mathrm{d}t,\]</p><p>for <span>$γ ∈ \mathcal X$</span> and <span>$ϕ ∈ T_γ\mathcal X$</span>.</p><p>Additionally, we have to take into account that boundary conditions <span>$γ(0) = γ_0$</span> and <span>$γ(T) = γ_T$</span> for given <span>$γ_0, γ_T ∈ \mathbb S^2$</span> are satisfied. This yields an elastic geodesic under a given force field <span>$ω: \mathbb S^2 → T^*\mathbb S^2$</span> connecting <span>$γ_0$</span> and <span>$γ_T$</span>.</p><p>For our example we set</p><pre><code class="language-julia hljs">    N = 50
    S = Manifolds.Sphere(2)
    power = PowerManifold(S, NestedPowerRepresentation(), N)

    mutable struct VariationalSpace
        manifold::AbstractManifold
        degree::Integer
    end

    test_space = VariationalSpace(S, 1)

    start_interval = 0.4
    end_interval = π - 0.4
    discrete_time = range(; start = start_interval, stop = end_interval, length=N+2) # equidistant discrete time points

    y0 = [sin(start_interval),0,cos(start_interval)] # startpoint of geodesic
    yT = [sin(end_interval),0,cos(end_interval)] # endpoint of geodesic</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
  0.3894183423086505
  0.0
 -0.9210609940028851</code></pre><p>As a starting point, we use the geodesic connecting <span>$γ_0$</span> and <span>$γ_T$</span>:</p><pre><code class="language-julia hljs">y(t) =  [sin(t), 0, cos(t)]
discretized_y = [y(ti) for ti in discrete_time[2:end-1]]</code></pre><pre><code class="nohighlight hljs">50-element Vector{Vector{Float64}}:
 [0.4312823089035602, 0.0, 0.9022170304460086]
 [0.47223726752861295, 0.0, 0.8814714760881995]
 [0.5121968979637886, 0.0, 0.8588680560576649]
 [0.5510769778290171, 0.0, 0.8344544112813096]
 [0.5887955600985645, 0.0, 0.8082819980725896]
 [0.6252731458196872, 0.0, 0.7804059796777266]
 [0.6604328516715138, 0.0, 0.7508851100088696]
 [0.6942005720109947, 0.0, 0.7197816098092585]
 [0.7265051350643781, 0.0, 0.6871610355113928]
 [0.7572784529350077, 0.0, 0.6530921410646137]
 ⋮
 [0.726505135064378, 0.0, -0.6871610355113931]
 [0.6942005720109946, 0.0, -0.7197816098092586]
 [0.6604328516715138, 0.0, -0.7508851100088696]
 [0.6252731458196874, 0.0, -0.7804059796777264]
 [0.5887955600985644, 0.0, -0.8082819980725897]
 [0.5510769778290171, 0.0, -0.8344544112813096]
 [0.5121968979637888, 0.0, -0.8588680560576648]
 [0.4722372675286131, 0.0, -0.8814714760881994]
 [0.43128230890356006, 0.0, -0.9022170304460086]</code></pre><p>In order to apply Newton’s method to find a zero of <span>$F$</span>, we need the linear mapping <span>$Q_{F(γ)}^*∘ F&#39;(γ)$</span> [<a href="../../references/#WeiglBergmannSchiela_2025">WBS25</a>] which can be seen as a covariant derivative. Since the sphere is an embedded submanifold of <span>$\mathbb R^3$</span>, we can use the formula</p><p class="math-container">\[Q_{F(γ)}^*∘ F&#39;(γ)δ γ\,ϕ = F(γ)(\overset{→}{V_γ&#39;}(γ)δ γ\,ϕ) + F_{\mathbb R^3}&#39;(γ)δ γ\,ϕ\]</p><p>for <span>$δ γ, \, ϕ ∈ T_γ \mathcal X$</span>, where <span>$\overset{→}{V_γ}(\hat γ) ∈ L(T_γ \mathcal X, T_{\hat{γ}}\mathcal X)$</span> is a vector transport and <span>$F_{\mathbb R^3}&#39;(γ)δ γ\, ϕ = \int_I ⟨ \dot{δ γ}(t),\dot{ϕ}(t)⟩ + ω&#39;(γ(t))δ γ(t)ϕ(t) \; \mathrm{d}t$</span> is the euclidean derivative of <span>$F$</span>.</p><p>We define a structure that has to be filled for two purposes:</p><ol><li>Definition of an integrand and its derivative</li><li>Definition of a vector transport and its derivative</li></ol><pre><code class="language-julia hljs">mutable struct DifferentiableMapping{F1&lt;:Function,F2&lt;:Function,T}
    value::F1
    derivative::F2
    scaling::T
end;</code></pre><p>The following routines define a vector transport and its euclidean derivative. As seen above, they are needed to derive a covariant derivative of <span>$F$</span>.</p><p>As a vector transport we use the (pointwise) orthogonal projection onto the tangent spaces, i.e. for <span>$p, q ∈ \mathbb S^2$</span> and <span>$X ∈ T_p\mathbb S^2$</span> we set</p><p class="math-container">\[\overset{→}{V}_{p}(q)X = (I-q ⋅  q^T)X ∈ T_q\mathbb S^2.\]</p><p>The derivative of the vector transport is then given by</p><p class="math-container">\[\left(\frac{d}{dq}\overset{→}{V}_{p}(q)\big\vert_{q=p}δ q\right)X = \left( - δ q ⋅  p^T - p ⋅  δ q^T\right) ⋅  X.\]</p><pre><code class="language-julia hljs">transport_by_proj(S, p, X, q) =  X - q*(q&#39;*X)

transport_by_proj_prime(S, p, X, dq) = (- dq*p&#39; - p*dq&#39;)*X

transport=DifferentiableMapping(transport_by_proj,transport_by_proj_prime,nothing)</code></pre><pre><code class="nohighlight hljs">DifferentiableMapping{typeof(transport_by_proj), typeof(transport_by_proj_prime), Nothing}(transport_by_proj, transport_by_proj_prime, nothing)</code></pre><p>The following two routines define the integrand of <span>$F$</span> and its euclidean derivative. They use a force field <span>$ω$</span>, which is defined, below. A scaling parameter for the force is also employed.</p><p>In this example we consider the force field <span>$ω: \mathbb S^2 → T^*\mathbb S^2$</span> given by the 1-form corresponding to a (scaled) winding field, i.e. for <span>$C∈\mathbb R$</span> and <span>$y∈ \mathbb{S}^2$</span> we set</p><p class="math-container">\[ω(y) := \frac{C y_3}{y_1^2+y_2^2}  ⋅  \bigg⟨ \begin{pmatrix} -y_2 \\ y_1 \\ 0 \end{pmatrix},  ⋅  \bigg⟩ ∈ (T_y\mathbb{S}^2)^*.\]</p><pre><code class="language-julia hljs">w(p, c) = c*p[3]*[-p[2]/(p[1]^2+p[2]^2), p[1]/(p[1]^2+p[2]^2), 0.0];</code></pre><p>Its derivative is given by</p><pre><code class="language-julia hljs">function w_prime(p, c)
    denominator = p[1]^2+p[2]^2

    return c*[p[3]*2*p[1]*p[2]/denominator^2 p[3]*(-1.0/denominator+2.0*p[2]^2/denominator^2) -p[2]/denominator; p[3]*(1.0/denominator-2.0*p[1]^2/(denominator^2)) p[3]*(-2.0*p[1]*p[2]/(denominator^2)) p[1]/denominator; 0.0 0.0 0.0]
end;</code></pre><pre><code class="language-julia hljs">F_at(Integrand, y, ydot, B, Bdot) = ydot&#39;*Bdot+w(y,Integrand.scaling)&#39;*B

F_prime_at(Integrand,y,ydot,B1,B1dot,B2,B2dot) = B1dot&#39;*B2dot+(w_prime(y,Integrand.scaling)*B1)&#39;*B2

integrand=DifferentiableMapping(F_at,F_prime_at,3.0)</code></pre><pre><code class="nohighlight hljs">DifferentiableMapping{typeof(F_at), typeof(F_prime_at), Float64}(F_at, F_prime_at, 3.0)</code></pre><h2 id="Newton-Equation"><a class="docs-heading-anchor" href="#Newton-Equation">Newton Equation</a><a id="Newton-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-Equation" title="Permalink"></a></h2><p>In this example we implement a functor to compute the Newton matrix and the right hand side for the Newton equation [<a href="../../references/#WeiglBergmannSchiela_2025">WBS25</a>]</p><p class="math-container">\[Q^*_{F(γ)}∘ F&#39;(γ)δ γ + F(γ) = 0^*_γ\]</p><p>by using the assembler provided in <code>ManoptExamples.jl</code>.</p><p>It returns the matrix and the right hand side in base representation.</p><p>The assembly routines need a function for evaluation the iterates at the left and right quadrature point.</p><pre><code class="language-julia hljs">evaluate(p, i, tloc) = (1.0-tloc)*p[i-1]+tloc*p[i];

struct NewtonEquation{F, TS, T, I, NM, Nrhs}
    integrand::F
    test_space::TS
    transport::T
    time_interval::I
    A::NM
    b::Nrhs
end

function NewtonEquation(M, F, test_space, VT, interval)
    n = manifold_dimension(M)
    A = spzeros(n,n)
    b = zeros(n)
    return NewtonEquation{typeof(F), typeof(test_space), typeof(VT), typeof(interval), typeof(A), typeof(b)}(F, test_space, VT, interval, A, b)
end

function (ne::NewtonEquation)(M, VB, p)
    n = manifold_dimension(M)
    ne.A .= spzeros(n,n)
    ne.b .= zeros(n)

    Op = OffsetArray([y0, p..., yT], 0:(length(p)+1))

    ManoptExamples.get_jacobian!(M, Op, evaluate, ne.A, ne.integrand, ne.transport, ne.time_interval; test_space = ne.test_space)
    ManoptExamples.get_right_hand_side!(M, Op, evaluate, ne.b, ne.integrand, ne.time_interval; test_space = ne.test_space)
end</code></pre><p>We compute the Newton direction <span>$δ γ$</span> by solving the linear system given by the base representation of the Newton equation directly and return the Newton direction in vector representation:</p><pre><code class="language-julia hljs">function solve_in_basis_repr(problem, newtonstate)
    X_base = (problem.newton_equation.A) \ (-problem.newton_equation.b)
    return get_vector(problem.manifold, newtonstate.p, X_base, DefaultOrthogonalBasis())
end</code></pre><pre><code class="nohighlight hljs">solve_in_basis_repr (generic function with 1 method)</code></pre><p>We adjust the norms for recording</p><pre><code class="language-julia hljs">    rec = RecordChange(power;
    inverse_retraction_method=ProjectionInverseRetraction());</code></pre><pre><code class="language-julia hljs">begin
    NE = NewtonEquation(power, integrand, test_space, transport, discrete_time)

    st_res = vectorbundle_newton(power, TangentBundle(power), NE, discretized_y; sub_problem=solve_in_basis_repr,
    stopping_criterion=( StopAfterIteration(150) | StopWhenChangeLess(power,1e-12; outer_norm=Inf, inverse_retraction_method=ProjectionInverseRetraction())),
    retraction_method=ProjectionRetraction(),
    debug=[:Iteration, (:Change, &quot;Change: %1.8e&quot;), &quot;\n&quot;, :Stop, (:Stepsize, &quot;Stepsize: %1.8e&quot;), &quot;\n&quot;,],
    record=[:Iterate, rec =&gt; :Change],
    return_state=true
    )
end</code></pre><pre><code class="nohighlight hljs">Initial

# 1     Change: 2.96686818e+00
Stepsize: 1.00000000e+00
# 2     Change: 3.86526790e-01
Stepsize: 1.00000000e+00
# 3     Change: 2.32737984e-02
Stepsize: 1.00000000e+00
# 4     Change: 2.19379934e-04
Stepsize: 1.00000000e+00
# 5     Change: 1.15340970e-08
Stepsize: 1.00000000e+00
# 6     Change: 6.63720131e-14
Stepsize: 1.00000000e+00
At iteration 6 the algorithm performed a step with a change (1.255273380563256e-14) less than 1.0e-12.

# Solver state for `Manopt.jl`s Vector bundle Newton method
After 6 iterations

## Parameters
* retraction method: ManifoldsBase.ProjectionRetraction()
* step size: ConstantLength(1.0; type=:relative)

## Stopping criterion

Stop When _one_ of the following are fulfilled:
  * Max Iteration 150:  not reached
  * |Δp| &lt; 1.0e-12: reached
Overall: reached
This indicates convergence: No

## Debug
    :Iteration = [ (:Iteration, &quot;# %-6d&quot;), (:Change, &quot;Change: %1.8e&quot;), &quot;\n&quot;, (:Stepsize, &quot;Stepsize: %1.8e&quot;), &quot;\n&quot; ]
    :Stop = :Stop

## Record
(Iteration = RecordGroup([RecordIterate(Vector{Vector{Float64}}), RecordChange(; inverse_retraction_method=ManifoldsBase.ProjectionInverseRetraction())]),)</code></pre><p>We extract the recorded values</p><pre><code class="language-julia hljs">    change = get_record(st_res, :Iteration, :Change)[2:end]
    p_res = get_solver_result(st_res)</code></pre><pre><code class="nohighlight hljs">50-element Vector{Vector{Float64}}:
 [0.3862072810538758, -0.09533087331847834, 0.9174725939521621]
 [0.3834594005073149, -0.17575240047635604, 0.9066807497070671]
 [0.38420034508283774, -0.24281962050178213, 0.8907461629092762]
 [0.38997618444778864, -0.2984067370816809, 0.8711325931382714]
 [0.40135535377804027, -0.34415448366457074, 0.8488059680323159]
 [0.4183423247899146, -0.3813361456953533, 0.8243618400166167]
 [0.44062875023728093, -0.41088642206997666, 0.7981344827927591]
 [0.4677303732599358, -0.43347156157671524, 0.7702796266514941]
 [0.49905909206373583, -0.449559252230437, 0.7408350027924774]
 [0.5339610863554352, -0.4594777974939836, 0.7097645467816784]
 ⋮
 [0.49905909206373367, 0.4495592522304387, -0.7408350027924779]
 [0.4677303732599338, 0.43347156157671657, -0.7702796266514944]
 [0.44062875023727915, 0.41088642206997783, -0.7981344827927593]
 [0.4183423247899131, 0.38133614569535446, -0.8243618400166169]
 [0.4013553537780388, 0.3441544836645715, -0.8488059680323162]
 [0.3899761844477874, 0.29840673708168164, -0.8711325931382716]
 [0.38420034508283685, 0.24281962050178285, -0.8907461629092766]
 [0.3834594005073143, 0.17575240047635673, -0.9066807497070672]
 [0.38620728105387553, 0.09533087331847828, -0.9174725939521623]</code></pre><p>and plot the result, where we measure the norms of the Newton direction in each iteration,</p><pre><code class="language-julia hljs">f = Figure(;)
row, col = fldmod1(1, 2)
Axis(f[row, col], yscale = log10, title = string(&quot;Norms of the Newton directions (semilogarithmic)&quot;), xminorgridvisible = true, xticks = (1:length(change)), xlabel = &quot;Iteration&quot;, ylabel = &quot;‖δ γ‖&quot;)
scatterlines!(change[1:end], color = :blue)
f</code></pre><p><img src="../Elastic-Geodesic-under-forcefield_files/figure-commonmark/cell-16-output-1.png" alt/></p><p>and the resulting elastic geodesic under the force field (orange). The starting geodesic (blue) is plotted as well. The force acting on each point of the geodesic is visualized by green arrows.</p><pre><code class="language-julia hljs">n = 25
u = range(0; stop=2 * π, length=n);
v = range(0; stop=π, length=n);
sx = zeros(n, n);
sy = zeros(n, n);
sz = zeros(n, n);

ws = [-w(p, integrand.scaling) for p in p_res]
ws_start = [-w(p, integrand.scaling) for p in discretized_y]
for i in 1:n
    for j in 1:n
        sx[i, j] = cos.(u[i]) * sin(v[j])
        sy[i, j] = sin.(u[i]) * sin(v[j])
        sz[i, j] = cos(v[j])
    end
end
fig, ax, plt = meshscatter(
    sx, sy, sz; color=RGBA(1.0, 1.0, 1.0, 0.0), shading=Makie.automatic, transparency=true
)
geodesic_start = [y0, discretized_y..., yT]
geodesic_final = [y0, p_res..., yT]
ax.show_axis = false
wireframe!(ax, sx, sy, sz; color=RGBA(0.5, 0.5, 0.7, 0.1), transparency=true)
π1(x) = 1.02 * x[1]
π2(x) = 1.02 * x[2]
π3(x) = 1.02 * x[3]
scatterlines!(
    ax, π1.(geodesic_final), π2.(geodesic_final), π3.(geodesic_final);
    markersize=5, color=:orange, linewidth=2,
)
scatterlines!(
    ax, π1.(geodesic_start), π2.(geodesic_start), π3.(geodesic_start);
    markersize=5, color=:blue, linewidth=2,
)
scatter!(ax, π1.([y0, yT]), π2.([y0, yT]), π3.([y0, yT]); markersize=5, color=:red)
arrows!(
    ax, π1.(p_res), π2.(p_res), π3.(p_res), π1.(ws), π2.(ws), π3.(ws);
    color=:green, linewidth=0.01,
    arrowsize=Vec3f(0.03, 0.03, 0.05), transparency=true, lengthscale=0.07,
)
cam = cameracontrols(ax.scene); cam.lookat[] = [-2.5, 2.5, 2]
fig</code></pre><p><img src="../Elastic-Geodesic-under-forcefield_files/figure-commonmark/cell-17-output-2.png" alt/></p><h2 id="Technical-details"><a class="docs-heading-anchor" href="#Technical-details">Technical details</a><a id="Technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-details" title="Permalink"></a></h2><p>This tutorial is cached. It was last run on the following package versions.</p><pre><code class="nohighlight hljs">Status `~/Repositories/Julia/ManoptExamples.jl/examples/Project.toml`
  [6e4b80f9] BenchmarkTools v1.6.3
  [336ed68f] CSV v0.10.15
⌃ [13f3f980] CairoMakie v0.15.7
  [0ca39b1e] Chairmarks v1.3.1
  [35d6a980] ColorSchemes v3.31.0
  [5ae59095] Colors v0.13.1
  [a93c6f00] DataFrames v1.8.1
  [31c24e10] Distributions v0.25.122
⌃ [e9467ef8] GLMakie v0.13.7
  [4d00f742] GeometryTypes v0.8.5
  [7073ff75] IJulia v1.33.0
  [682c06a0] JSON v1.3.0
  [8ac3fa9e] LRUCache v1.6.2
  [b964fa9f] LaTeXStrings v1.4.0
⌃ [d3d80556] LineSearches v7.4.1
⌅ [ee78f7c6] Makie v0.24.7
  [af67fdf4] ManifoldDiff v0.4.5
⌃ [1cead3c2] Manifolds v0.11.6
⌃ [3362f125] ManifoldsBase v2.2.1
⌃ [0fc0a36d] Manopt v0.5.28
  [5b8d5e80] ManoptExamples v0.1.17 `..`
  [51fcb6bd] NamedColors v0.2.3
  [6fe1bfb0] OffsetArrays v1.17.0
  [91a5bcdd] Plots v1.41.2
  [08abe8d2] PrettyTables v3.1.2
  [6099a3de] PythonCall v0.9.30
  [f468eda6] QuadraticModels v0.9.14
  [731186ca] RecursiveArrayTools v3.39.0
  [1e40b3f8] RipQP v0.7.0
Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`</code></pre><p>This tutorial was last rendered December 14, 2025, 11:26:10.</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[WBS25]</dt><dd><div>L. Weigl, R. Bergmann and A. Schiela. <em>Newton&#39;s method into vector bundles Part II: : Application to Variational Problems on Manifolds</em>, <a href="https://doi.org/10.48550/ARXIV.2507.13836">arXiv Preprint</a> (2025).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Total-Variation/">« Total Variation</a><a class="docs-footer-nextpage" href="../Elastic-Geodesic-Obstacle/">Elastic Geodesic Obstacle »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 20 January 2026 11:14">Tuesday 20 January 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
