<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Objectives ¬∑ ManoptExamples.jl</title><meta name="title" content="Objectives ¬∑ ManoptExamples.jl"/><meta property="og:title" content="Objectives ¬∑ ManoptExamples.jl"/><meta property="twitter:title" content="Objectives ¬∑ ManoptExamples.jl"/><meta name="description" content="Documentation for ManoptExamples.jl."/><meta property="og:description" content="Documentation for ManoptExamples.jl."/><meta property="twitter:description" content="Documentation for ManoptExamples.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ManoptExamples.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Difference of Convex</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/Difference-of-Convex-Benchmark/">A Benchmark</a></li><li><a class="tocitem" href="../examples/Difference-of-Convex-Rosenbrock/">Rosenbrock Metric</a></li><li><a class="tocitem" href="../examples/Difference-of-Convex-Frank-Wolfe/">Frank Wolfe comparison</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Convex Bundle Method</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/RCBM-Median/">Riemannian Median</a></li><li><a class="tocitem" href="../examples/H2-Signal-TV/">Hyperbolic Signal Denoising</a></li><li><a class="tocitem" href="../examples/Spectral-Procrustes/">Spectral Procrustes</a></li></ul></li><li><a class="tocitem" href="../examples/HyperparameterOptimization/">Hyperparameter optimziation</a></li><li><a class="tocitem" href="../examples/RayleighQuotient/">The Rayleigh Quotient</a></li><li><a class="tocitem" href="../examples/Riemannian-mean/">Riemannian Mean</a></li><li><a class="tocitem" href="../examples/Robust-PCA/">Robust PCA</a></li><li><a class="tocitem" href="../examples/Rosenbrock/">Rosenbrock</a></li><li><a class="tocitem" href="../examples/Total-Variation/">Total Variation</a></li></ul></li><li class="is-active"><a class="tocitem" href>Objectives</a><ul class="internal"><li><a class="tocitem" href="#Rayleigh"><span>Rayleigh Quotient on the Sphere</span></a></li><li><a class="tocitem" href="#BezierCurves"><span>B√©zier Curves</span></a></li><li><a class="tocitem" href="#RiemannianMean"><span>Riemannian Mean</span></a></li><li><a class="tocitem" href="#RobustPCA"><span>Robust PCA</span></a></li><li><a class="tocitem" href="#Rosenbrock"><span>Rosenbrock Function</span></a></li><li><a class="tocitem" href="#Total-Variation"><span>Total Variation</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../data/">Data</a></li><li><a class="tocitem" href="../contributing/">Contributing to ManoptExamples.jl</a></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Objectives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Objectives</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManoptExamples.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/main/docs/src/objectives/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-Objectives-defined-for-the-Examples"><a class="docs-heading-anchor" href="#List-of-Objectives-defined-for-the-Examples">List of Objectives defined for the Examples</a><a id="List-of-Objectives-defined-for-the-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-Objectives-defined-for-the-Examples" title="Permalink"></a></h1><h2 id="Rayleigh"><a class="docs-heading-anchor" href="#Rayleigh">Rayleigh Quotient on the Sphere</a><a id="Rayleigh-1"></a><a class="docs-heading-anchor-permalink" href="#Rayleigh" title="Permalink"></a></h2><p>See the Rayleigh example (TODO) to see these in use.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RayleighQuotientCost" href="#ManoptExamples.RayleighQuotientCost"><code>ManoptExamples.RayleighQuotientCost</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RayleighQuotientCost</code></pre><p>A functor representing the Rayleigh Quotient cost function.</p><p>Let <span>$A ‚àà ‚Ñù^{n√ón}$</span> be a symmetric matrix. Then we can specify the <a href="https://en.wikipedia.org/wiki/Rayleigh_quotient">Rayleigh Quotient</a> in two forms. Either</p><p class="math-container">\[f(p) = p^{\mathrm{T}}Ap,\qquad p ‚àà ùïä^{n-1},\]</p><p>or extended into the embedding as</p><p class="math-container">\[f(x) = x^{\mathrm{T}}Ax, \qquad x ‚àà ‚Ñù^n,\]</p><p>which is not the orignal Rayleigh quotient for performance reasons, but useful if you want to use this as the Euclidean cost in the emedding of <span>$ùïä^{n-1}$</span>.</p><p><strong>Fields</strong></p><ul><li><code>A</code> ‚Äì storing the matrix internally</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RayleighQuotientCost(A)</code></pre><p>Create the Rayleigh cost function.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.RayleighQuotientGrad!!"><code>RayleighQuotientGrad!!</code></a>, <a href="#ManoptExamples.RayleighQuotientHess!!"><code>RayleighQuotientHess!!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RayleighQuotient.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RayleighQuotientGrad!!" href="#ManoptExamples.RayleighQuotientGrad!!"><code>ManoptExamples.RayleighQuotientGrad!!</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RayleighQuotientGrad!!</code></pre><p>A functor representing the Rayleigh Quotient gradient function.</p><p>Let <span>$A ‚àà ‚Ñù^{n√ón}$</span> be a symmetric matrix. Then we can specify the gradient of the <a href="https://en.wikipedia.org/wiki/Rayleigh_quotient">Rayleigh Quotient</a> in two forms. Either</p><p class="math-container">\[\operatorname{grad} f(p) = 2 Ap - 2 (p^{\mathrm{T}}Ap)*p,\qquad p ‚àà ùïä^{n-1},\]</p><p>or taking the Euclidean gradient of the Rayleigh quotient on the sphere as</p><p class="math-container">\[‚àáf(x) = 2Ax, \qquad x ‚àà ‚Ñù^n.\]</p><p>For details, see Example 3.62 of [<a href="../references/#Boumal:2023">Bou23</a>].</p><p><strong>Fields</strong></p><ul><li><code>A</code> ‚Äì storing the matrix internally</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RayleighQuotientGrad!!(A)</code></pre><p>Create the Rayleigh quotient gradient function.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.RayleighQuotientCost"><code>RayleighQuotientCost</code></a>, <a href="#ManoptExamples.RayleighQuotientHess!!"><code>RayleighQuotientHess!!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RayleighQuotient.jl#L46-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RayleighQuotientHess!!" href="#ManoptExamples.RayleighQuotientHess!!"><code>ManoptExamples.RayleighQuotientHess!!</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RayleighQuotientHess!!</code></pre><p>A functor representing the Rayleigh Quotient Hessian.</p><p>Let <span>$A ‚àà ‚Ñù^{n√ón}$</span> be a symmetric matrix. Then we can specify the Hessian of the <a href="https://en.wikipedia.org/wiki/Rayleigh_quotient">Rayleigh Quotient</a> in two forms. Either</p><p class="math-container">\[\operatorname{Hess} f(p)[X] = 2 \bigl(AX - (p^{mathrm{T}}AX)p - (p^{\mathrm{T}}Ap)X\bigr),\qquad p ‚àà ùïä^{n-1}, X \in T_pùïä^{n-1}\]</p><p>or taking the Euclidean Hessian of the Rayleigh quotient on the sphere as</p><p class="math-container">\[‚àá^2f(x)[V] = 2AV, \qquad x, V ‚àà ‚Ñù^n.\]</p><p>For details, see Example 5.27 of [<a href="../references/#Boumal:2023">Bou23</a>].</p><p><strong>Fields</strong></p><ul><li><code>A</code> ‚Äì storing the matrix internally</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RayleighQuotientHess!!(A)</code></pre><p>Create the Rayleigh quotient Hessian function.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.RayleighQuotientCost"><code>RayleighQuotientCost</code></a>, <a href="#ManoptExamples.RayleighQuotientGrad!!"><code>RayleighQuotientGrad!!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RayleighQuotient.jl#L99-L133">source</a></section></article><h2 id="BezierCurves"><a class="docs-heading-anchor" href="#BezierCurves">B√©zier Curves</a><a id="BezierCurves-1"></a><a class="docs-heading-anchor-permalink" href="#BezierCurves" title="Permalink"></a></h2><p>See the <a href="../examples/Bezier-curves/">Bezier Curves example</a> to see these in use.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.BezierSegment" href="#ManoptExamples.BezierSegment"><code>ManoptExamples.BezierSegment</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BezierSegment</code></pre><p>A type to capture a Bezier segment. With <span>$n$</span> points, a B√©zier segment of degree <span>$n-1$</span> is stored. On the Euclidean manifold, this yields a polynomial of degree <span>$n-1$</span>.</p><p>This type is mainly used to encapsulate the points within a composite Bezier curve, which consist of an <code>AbstractVector</code> of <code>BezierSegments</code> where each of the points might be a nested array on a <code>PowerManifold</code> already.</p><p>Not that this can also be used to represent tangent vectors on the control points of a segment.</p><p>See also: <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">BezierSegment(pts::AbstractVector)</code></pre><p>Given an abstract vector of <code>pts</code> generate the corresponding B√©zier segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}, AbstractFloat, AbstractVector{P}}} where P" href="#ManoptExamples.L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}, AbstractFloat, AbstractVector{P}}} where P"><code>ManoptExamples.L2_acceleration_Bezier</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2_acceleration_Bezier(M,B,pts,Œª,d)</code></pre><p>compute the value of the discrete Acceleration of the composite Bezier curve together with a data term, i.e.</p><p class="math-container">\[\frac{Œª}{2}\sum_{i=0}^{N} d_{\mathcal M}(d_i, c_B(i))^2+
\sum_{i=1}^{N-1}\frac{d^2_2 [ B(t_{i-1}), B(t_{i}), B(t_{i+1})]}{\Delta_t^3}\]</p><p>where for this formula the <code>pts</code> along the curve are equispaced and denoted by <span>$t_i$</span> and <span>$d_2$</span> refers to the second order absolute difference <a href="#ManoptExamples.second_order_Total_Variation"><code>second_order_Total_Variation</code></a> (squared), the junction points are denoted by <span>$p_i$</span>, and to each <span>$p_i$</span> corresponds one data item in the manifold points given in <code>d</code>. For details on the acceleration approximation, see <a href="#ManoptExamples.acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}}} where P"><code>acceleration_Bezier</code></a>. Note that the B√©zier-curve is given in reduces form as a point on a <code>PowerManifold</code>, together with the <code>degrees</code> of the segments and assuming a differentiable curve, the segments can internally be reconstructed.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.grad_L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector, Any, AbstractVector{P}}} where P"><code>grad_L2_acceleration_Bezier</code></a>, <a href="#ManoptExamples.acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}}} where P"><code>acceleration_Bezier</code></a>, <a href="#ManoptExamples.grad_acceleration_Bezier-Tuple{ManifoldsBase.AbstractManifold, AbstractVector, AbstractVector{&lt;:Integer}, AbstractVector}"><code>grad_acceleration_Bezier</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L381-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}}} where P" href="#ManoptExamples.acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}}} where P"><code>ManoptExamples.acceleration_Bezier</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acceleration_Bezier(
    M::AbstractManifold,
    B::AbstractVector{P},
    degrees::AbstractVector{&lt;:Integer},
    T::AbstractVector{&lt;:AbstractFloat},
) where {P}</code></pre><p>compute the value of the discrete Acceleration of the composite Bezier curve</p><p class="math-container">\[\sum_{i=1}^{N-1}\frac{d^2_2 [ B(t_{i-1}), B(t_{i}), B(t_{i+1})]}{\Delta_t^3}\]</p><p>where for this formula the <code>pts</code> along the curve are equispaced and denoted by <span>$t_i$</span>, <span>$i=1,‚Ä¶,N$</span>, and <span>$d_2$</span> refers to the second order absolute difference <a href="#ManoptExamples.second_order_Total_Variation"><code>second_order_Total_Variation</code></a> (squared). Note that the B√©zier-curve is given in reduces form as a point on a <code>PowerManifold</code>, together with the <code>degrees</code> of the segments and assuming a differentiable curve, the segments can internally be reconstructed.</p><p>This acceleration discretization was introduced in <a href="../references/#BergmannGousenbourger:2018">Bergmann, Gousenbourger, Front. Appl. Math. Stat., 2018</a>.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.grad_acceleration_Bezier-Tuple{ManifoldsBase.AbstractManifold, AbstractVector, AbstractVector{&lt;:Integer}, AbstractVector}"><code>grad_acceleration_Bezier</code></a>, <a href="#ManoptExamples.L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}, AbstractFloat, AbstractVector{P}}} where P"><code>L2_acceleration_Bezier</code></a>, <a href="#ManoptExamples.grad_L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector, Any, AbstractVector{P}}} where P"><code>grad_L2_acceleration_Bezier</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L339-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.adjoint_differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}, AbstractVector, AbstractVector}" href="#ManoptExamples.adjoint_differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}, AbstractVector, AbstractVector}"><code>ManoptExamples.adjoint_differential_Bezier_control_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint_differential_Bezier_control_points(
    M::AbstractManifold,
    T::AbstractVector,
    X::AbstractVector,
)
adjoint_differential_Bezier_control_points!(
    M::AbstractManifold,
    Y::AbstractVector{&lt;:BezierSegment},
    T::AbstractVector,
    X::AbstractVector,
)</code></pre><p>Evaluate the adjoint of the differential with respect to the controlpoints at several times <code>T</code>. This can be computed in place of <code>Y</code>.</p><p>See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L788-L805">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.adjoint_differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}, Any, Any}" href="#ManoptExamples.adjoint_differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}, Any, Any}"><code>ManoptExamples.adjoint_differential_Bezier_control_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint_differential_Bezier_control_points(
    M::AbstractManifold,
    B::AbstractVector{&lt;:BezierSegment},
    t,
    X
)
adjoint_differential_Bezier_control_points!(
    M::AbstractManifold,
    Y::AbstractVector{&lt;:BezierSegment},
    B::AbstractVector{&lt;:BezierSegment},
    t,
    X
)</code></pre><p>evaluate the adjoint of the differential of a composite B√©zier curve on the manifold <code>M</code> with respect to its control points <code>b</code> based on a points <code>T</code><span>$=(t_i)_{i=1}^n$</span> that are pointwise in <span>$t_i‚àà[0,1]$</span> on the curve and given corresponding tangential vectors <span>$X = (Œ∑_i)_{i=1}^n$</span>, <span>$Œ∑_i‚ààT_{Œ≤(t_i)}\mathcal M$</span> This can be computed in place of <code>Y</code>.</p><p>See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L734-L756">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.adjoint_differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment, AbstractVector, AbstractVector}" href="#ManoptExamples.adjoint_differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment, AbstractVector, AbstractVector}"><code>ManoptExamples.adjoint_differential_Bezier_control_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint_differential_Bezier_control_points(
    M::AbstractManifold,
    b::BezierSegment,
    t::AbstractVector,
    X::AbstractVector,
)
adjoint_differential_Bezier_control_points!(
    M::AbstractManifold,
    Y::BezierSegment,
    b::BezierSegment,
    t::AbstractVector,
    X::AbstractVector,
)</code></pre><p>evaluate the adjoint of the differential of a B√©zier curve on the manifold <code>M</code> with respect to its control points <code>b</code> based on a points <code>T</code><span>$=(t_i)_{i=1}^n$</span> that are pointwise in <span>$t_i‚àà[0,1]$</span> on the curve and given corresponding tangential vectors <span>$X = (Œ∑_i)_{i=1}^n$</span>, <span>$Œ∑_i‚ààT_{Œ≤(t_i)}\mathcal M$</span> This can be computed in place of <code>Y</code>.</p><p>See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve and <a href="../references/#BergmannGousenbourger:2018">Bergmann, Gousenbourger, Front. Appl. Math. Stat., 2018</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L688-L709">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.adjoint_differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment, Any, Any}" href="#ManoptExamples.adjoint_differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment, Any, Any}"><code>ManoptExamples.adjoint_differential_Bezier_control_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint_differential_Bezier_control_points(M::AbstractManifold, b::BezierSegment, t, Œ∑)
adjoint_differential_Bezier_control_points!(
    M::AbstractManifold,
    Y::BezierSegment,
    b::BezierSegment,
    t,
    Œ∑,
)</code></pre><p>evaluate the adjoint of the differential of a B√©zier curve on the manifold <code>M</code> with respect to its control points <code>b</code> based on a point <code>t</code><span>$‚àà[0,1]$</span> on the curve and a tangent vector <span>$Œ∑‚ààT_{Œ≤(t)}\mathcal M$</span>. This can be computed in place of <code>Y</code>.</p><p>See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L605-L621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}" href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>ManoptExamples.de_Casteljau</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">de_Casteljau(M::AbstractManifold, b::BezierSegment NTuple{N,P}) -&gt; Function</code></pre><p>return the <a href="https://en.wikipedia.org/wiki/B√©zier_curve">B√©zier curve</a> <span>$Œ≤(‚ãÖ;b_0,‚Ä¶,b_n): [0,1] ‚Üí \mathcal M$</span> defined by the control points <span>$b_0,‚Ä¶,b_n‚àà\mathcal M$</span>, <span>$n‚àà\mathbb N$</span>, as a <a href="#ManoptExamples.BezierSegment"><code>BezierSegment</code></a>. This function implements de Casteljau&#39;s algorithm <a href="../references/#deCasteljau:1959">Casteljau, 1959</a>, <a href="../references/#deCasteljau:1963">Casteljau, 1963</a> generalized to manifolds by <a href="../references/#PopielNoakes:2007">Popiel, Noakes, J Approx Theo, 2007</a>: Let <span>$Œ≥_{a,b}(t)$</span> denote the shortest geodesic connecting <span>$a,b‚àà\mathcal M$</span>. Then the curve is defined by the recursion</p><p class="math-container">\[\begin{aligned}
    Œ≤(t;b_0,b_1) &amp;= \gamma_{b_0,b_1}(t)\\
    Œ≤(t;b_0,‚Ä¶,b_n) &amp;= \gamma_{Œ≤(t;b_0,‚Ä¶,b_{n-1}), Œ≤(t;b_1,‚Ä¶,b_n)}(t),
\end{aligned}\]</p><p>and <code>P</code> is the type of a point on the <code>Manifold</code> <code>M</code>.</p><pre><code class="nohighlight hljs">de_Casteljau(M::AbstractManifold, B::AbstractVector{&lt;:BezierSegment}) -&gt; Function</code></pre><p>Given a vector of B√©zier segments, i.e. a vector of control points <span>$B=\bigl( (b_{0,0},‚Ä¶,b_{n_0,0}),‚Ä¶,(b_{0,m},‚Ä¶ b_{n_m,m}) \bigr)$</span>, where the different segments might be of different degree(s) <span>$n_0,‚Ä¶,n_m$</span>. The resulting composite B√©zier curve <span>$c_B:[0,m] ‚Üí \mathcal M$</span> consists of <span>$m$</span> segments which are B√©zier curves.</p><p class="math-container">\[c_B(t) :=
    \begin{cases}
        Œ≤(t; b_{0,0},‚Ä¶,b_{n_0,0}) &amp; \text{ if } t ‚àà[0,1]\\
        Œ≤(t-i; b_{0,i},‚Ä¶,b_{n_i,i}) &amp; \text{ if }
            t‚àà(i,i+1], \quad i‚àà\{1,‚Ä¶,m-1\}.
    \end{cases}\]</p><pre><code class="language-julia hljs">de_Casteljau(M::AbstractManifold, b::BezierSegment, t::Real)
de_Casteljau(M::AbstractManifold, B::AbstractVector{&lt;:BezierSegment}, t::Real)
de_Casteljau(M::AbstractManifold, b::BezierSegment, T::AbstractVector) -&gt; AbstractVector
de_Casteljau(
    M::AbstractManifold,
    B::AbstractVector{&lt;:BezierSegment},
    T::AbstractVector
) -&gt; AbstractVector</code></pre><p>Evaluate the B√©zier curve at time <code>t</code> or at times <code>t</code> in <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L29-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}, AbstractVector, AbstractVector{&lt;:ManoptExamples.BezierSegment}}" href="#ManoptExamples.differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}, AbstractVector, AbstractVector{&lt;:ManoptExamples.BezierSegment}}"><code>ManoptExamples.differential_Bezier_control_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differential_Bezier_control_points(
    M::AbstractManifold,
    B::AbstractVector{&lt;:BezierSegment},
    T::AbstractVector
    Œû::AbstractVector{&lt;:BezierSegment}
)
differential_Bezier_control_points!(
    M::AbstractManifold,
    Œò::AbstractVector{&lt;:BezierSegment}
    B::AbstractVector{&lt;:BezierSegment},
    T::AbstractVector
    Œû::AbstractVector{&lt;:BezierSegment}
)</code></pre><p>evaluate the differential of the composite B√©zier curve with respect to its control points <code>B</code> and tangent vectors <code>Œû</code> in the tangent spaces of the control points. The result is the ‚Äúchange‚Äù of the curve at the points in <code>T</code>, which are elementwise in <span>$[0,N]$</span>, and each depending the corresponding segment(s). Here, <span>$N$</span> is the length of <code>B</code>. For the mutating variant the result is computed in <code>Œò</code>.</p><p>See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve and <a href="../references/#BergmannGousenbourger:2018">Bergmann, Gousenbourger, Front. Appl. Math. Stat., 2018</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L563-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}, Any, AbstractVector{&lt;:ManoptExamples.BezierSegment}}" href="#ManoptExamples.differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}, Any, AbstractVector{&lt;:ManoptExamples.BezierSegment}}"><code>ManoptExamples.differential_Bezier_control_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differential_Bezier_control_points(
    M::AbstractManifold,
    B::AbstractVector{&lt;:BezierSegment},
    t,
    X::AbstractVector{&lt;:BezierSegment}
)
differential_Bezier_control_points!(
    M::AbstractManifold,
    Y::AbstractVector{&lt;:BezierSegment}
    B::AbstractVector{&lt;:BezierSegment},
    t,
    X::AbstractVector{&lt;:BezierSegment}
)</code></pre><p>evaluate the differential of the composite B√©zier curve with respect to its control points <code>B</code> and tangent vectors <code>Œû</code> in the tangent spaces of the control points. The result is the ‚Äúchange‚Äù of the curve at <code>t</code><span>$‚àà[0,N]$</span>, which depends only on the corresponding segment. Here, <span>$N$</span> is the length of <code>B</code>. The computation can be done in place of <code>Y</code>.</p><p>See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L494-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment, AbstractVector, ManoptExamples.BezierSegment}" href="#ManoptExamples.differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment, AbstractVector, ManoptExamples.BezierSegment}"><code>ManoptExamples.differential_Bezier_control_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differential_Bezier_control_points(
    M::AbstractManifold,
    b::BezierSegment,
    T::AbstractVector,
    X::BezierSegment,
)
differential_Bezier_control_points!(
    M::AbstractManifold,
    Y,
    b::BezierSegment,
    T::AbstractVector,
    X::BezierSegment,
)</code></pre><p>evaluate the differential of the B√©zier curve with respect to its control points <code>b</code> and tangent vectors <code>X</code> in the tangent spaces of the control points. The result is the ‚Äúchange‚Äù of the curve at the points <code>T</code>, elementwise in <span>$t‚àà[0,1]$</span>. The computation can be done in place of <code>Y</code>.</p><p>See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L462-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment, Any, ManoptExamples.BezierSegment}" href="#ManoptExamples.differential_Bezier_control_points-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment, Any, ManoptExamples.BezierSegment}"><code>ManoptExamples.differential_Bezier_control_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differential_Bezier_control_points(M::AbstractManifold, b::BezierSegment, t::Float, X::BezierSegment)
differential_Bezier_control_points!(
    M::AbstractManifold,
    Y,
    b::BezierSegment,
    t,
    X::BezierSegment
)</code></pre><p>evaluate the differential of the B√©zier curve with respect to its control points <code>b</code> and tangent vectors <code>X</code> given in the tangent spaces of the control points. The result is the ‚Äúchange‚Äù of the curve at <code>t</code><span>$‚àà[0,1]$</span>. The computation can be done in place of <code>Y</code>.</p><p>See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L421-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.get_Bezier_degree-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment}" href="#ManoptExamples.get_Bezier_degree-Tuple{ManifoldsBase.AbstractManifold, ManoptExamples.BezierSegment}"><code>ManoptExamples.get_Bezier_degree</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Bezier_degree(M::AbstractManifold, b::BezierSegment)</code></pre><p>return the degree of the B√©zier curve represented by the tuple <code>b</code> of control points on the manifold <code>M</code>, i.e. the number of points minus 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L233-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.get_Bezier_degrees-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}}" href="#ManoptExamples.get_Bezier_degrees-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}}"><code>ManoptExamples.get_Bezier_degrees</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Bezier_degrees(M::AbstractManifold, B::AbstractVector{&lt;:BezierSegment})</code></pre><p>return the degrees of the components of a composite B√©zier curve represented by tuples in <code>B</code> containing points on the manifold <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.get_Bezier_inner_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}}" href="#ManoptExamples.get_Bezier_inner_points-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}}"><code>ManoptExamples.get_Bezier_inner_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Bezier_inner_points(M::AbstractManifold, B::AbstractVector{&lt;:BezierSegment} )
get_Bezier_inner_points(M::AbstractManifold, b::BezierSegment)</code></pre><p>returns the inner (i.e. despite start and end) points of the segments of the composite B√©zier curve specified by the control points <code>B</code>. For a single segment <code>b</code>, its inner points are returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.get_Bezier_junction_tangent_vectors-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}}" href="#ManoptExamples.get_Bezier_junction_tangent_vectors-Tuple{ManifoldsBase.AbstractManifold, AbstractVector{&lt;:ManoptExamples.BezierSegment}}"><code>ManoptExamples.get_Bezier_junction_tangent_vectors</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Bezier_junction_tangent_vectors(M::AbstractManifold, B::AbstractVector{&lt;:BezierSegment})
get_Bezier_junction_tangent_vectors(M::AbstractManifold, b::BezierSegment)</code></pre><p>returns the tangent vectors at start and end points of the composite B√©zier curve pointing from a junction point to the first and last inner control points for each segment of the composite Bezier curve specified by the control points <code>B</code>, either a vector of segments of controlpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L128-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.get_Bezier_junctions" href="#ManoptExamples.get_Bezier_junctions"><code>ManoptExamples.get_Bezier_junctions</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Bezier_junctions(M::AbstractManifold, B::AbstractVector{&lt;:BezierSegment})
get_Bezier_junctions(M::AbstractManifold, b::BezierSegment)</code></pre><p>returns the start and end point(s) of the segments of the composite B√©zier curve specified by the control points <code>B</code>. For just one segment <code>b</code>, its start and end points are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.get_Bezier_points" href="#ManoptExamples.get_Bezier_points"><code>ManoptExamples.get_Bezier_points</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Bezier_points(
    M::AbstractManifold,
    B::AbstractVector{&lt;:BezierSegment},
    reduce::Symbol=:default
)
get_Bezier_points(M::AbstractManifold, b::BezierSegment, reduce::Symbol=:default)</code></pre><p>returns the control points of the segments of the composite B√©zier curve specified by the control points <code>B</code>, either a vector of segments of controlpoints or a.</p><p>This method reduces the points depending on the optional <code>reduce</code> symbol</p><ul><li><code>:default</code>:        no reduction is performed</li><li><code>:continuous</code>:     for a continuous function, the junction points are doubled at <span>$b_{0,i}=b_{n_{i-1},i-1}$</span>, so only <span>$b_{0,i}$</span> is in the vector.</li><li><code>:differentiable</code>: for a differentiable function additionally <span>$\log_{b_{0,i}}b_{1,i} = -\log_{b_{n_{i-1},i-1}}b_{n_{i-1}-1,i-1}$</span> holds. hence <span>$b_{n_{i-1}-1,i-1}$</span> is omitted.</li></ul><p>If only one segment is given, all points of <code>b</code>, <code>b.pts</code>, is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L186-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.get_Bezier_segments-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, Vector{P}, Any}, Tuple{ManifoldsBase.AbstractManifold, Vector{P}, Any, Symbol}} where P" href="#ManoptExamples.get_Bezier_segments-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, Vector{P}, Any}, Tuple{ManifoldsBase.AbstractManifold, Vector{P}, Any, Symbol}} where P"><code>ManoptExamples.get_Bezier_segments</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Bezier_segments(M::AbstractManifold, c::AbstractArray{P}, d[, s::Symbol=:default])</code></pre><p>returns the array of <a href="#ManoptExamples.BezierSegment"><code>BezierSegment</code></a>s <code>B</code> of a composite B√©zier curve reconstructed from an array <code>c</code> of points on the manifold <code>M</code> and an array of degrees <code>d</code>.</p><p>There are a few (reduced) representations that can get extended; see also <a href="#ManoptExamples.get_Bezier_points"><code>get_Bezier_points</code></a>. For ease of the following, let <span>$c=(c_1,‚Ä¶,c_k)$</span> and <span>$d=(d_1,‚Ä¶,d_m)$</span>, where <span>$m$</span> denotes the number of components the composite B√©zier curve consists of. Then</p><ul><li><code>:default</code>: <span>$k = m + \sum_{i=1}^m d_i$</span> since each component requires one point more than its degree. The points are then ordered in tuples, i.e.<p class="math-container">\[B = \bigl[ [c_1,‚Ä¶,c_{d_1+1}], (c_{d_1+2},‚Ä¶,c_{d_1+d_2+2}],‚Ä¶, [c_{k-m+1+d_m},‚Ä¶,c_{k}] \bigr]\]</p></li><li><code>:continuous</code>: <span>$k = 1+ \sum_{i=1}{m} d_i$</span>, since for a continuous curve start and end point of successive components are the same, so the very first start point and the end points are stored.<p class="math-container">\[B = \bigl[ [c_1,‚Ä¶,c_{d_1+1}], [c_{d_1+1},‚Ä¶,c_{d_1+d_2+1}],‚Ä¶, [c_{k-1+d_m},‚Ä¶,b_{k}) \bigr]\]</p></li><li><code>:differentiable</code> ‚Äì for a differentiable function additionally to the last explanation, also the second point of any segment was not stored except for the first segment. Hence <span>$k = 2 - m + \sum_{i=1}{m} d_i$</span> and at a junction point <span>$b_n$</span> with its given prior point <span>$c_{n-1}$</span>, i.e. this is the last inner point of a segment, the first inner point in the next segment the junction is computed as <span>$b = \exp_{c_n}(-\log_{c_n} c_{n-1})$</span> such that the assumed differentiability holds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L251-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.grad_L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector, Any, AbstractVector{P}}} where P" href="#ManoptExamples.grad_L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector, Any, AbstractVector{P}}} where P"><code>ManoptExamples.grad_L2_acceleration_Bezier</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad_L2_acceleration_Bezier(
    M::AbstractManifold,
    B::AbstractVector{P},
    degrees::AbstractVector{&lt;:Integer},
    T::AbstractVector,
    Œª,
    d::AbstractVector{P}
) where {P}</code></pre><p>compute the gradient of the discretized acceleration of a composite B√©zier curve on the <code>Manifold</code> <code>M</code> with respect to its control points <code>B</code> together with a data term that relates the junction points <code>p_i</code> to the data <code>d</code> with a weight <span>$Œª$</span> compared to the acceleration. The curve is evaluated at the points given in <code>pts</code> (elementwise in <span>$[0,N]$</span>), where <span>$N$</span> is the number of segments of the B√©zier curve. The summands are <a href><code>grad_distance</code></a> for the data term and <a href="#ManoptExamples.grad_acceleration_Bezier-Tuple{ManifoldsBase.AbstractManifold, AbstractVector, AbstractVector{&lt;:Integer}, AbstractVector}"><code>grad_acceleration_Bezier</code></a> for the acceleration with interpolation constrains. Here the <a href="#ManoptExamples.get_Bezier_junctions"><code>get_Bezier_junctions</code></a> are included in the optimization, i.e. setting <span>$Œª=0$</span> yields the unconstrained acceleration minimization. Note that this is ill-posed, since any B√©zier curve identical to a geodesic is a minimizer.</p><p>Note that the B√©zier-curve is given in reduces form as a point on a <code>PowerManifold</code>, together with the <code>degrees</code> of the segments and assuming a differentiable curve, the segments can internally be reconstructed.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.grad_acceleration_Bezier-Tuple{ManifoldsBase.AbstractManifold, AbstractVector, AbstractVector{&lt;:Integer}, AbstractVector}"><code>grad_acceleration_Bezier</code></a>, <a href="#ManoptExamples.L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}, AbstractFloat, AbstractVector{P}}} where P"><code>L2_acceleration_Bezier</code></a>, <a href="#ManoptExamples.acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}}} where P"><code>acceleration_Bezier</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L877-L905">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.grad_acceleration_Bezier-Tuple{ManifoldsBase.AbstractManifold, AbstractVector, AbstractVector{&lt;:Integer}, AbstractVector}" href="#ManoptExamples.grad_acceleration_Bezier-Tuple{ManifoldsBase.AbstractManifold, AbstractVector, AbstractVector{&lt;:Integer}, AbstractVector}"><code>ManoptExamples.grad_acceleration_Bezier</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad_acceleration_Bezier(
    M::AbstractManifold,
    B::AbstractVector,
    degrees::AbstractVector{&lt;:Integer}
    T::AbstractVector
)</code></pre><p>compute the gradient of the discretized acceleration of a (composite) B√©zier curve <span>$c_B(t)$</span> on the <code>Manifold</code> <code>M</code> with respect to its control points <code>B</code> given as a point on the <code>PowerManifold</code> assuming C1 conditions and known <code>degrees</code>. The curve is evaluated at the points given in <code>T</code> (elementwise in <span>$[0,N]$</span>, where <span>$N$</span> is the number of segments of the B√©zier curve). The <a href="#ManoptExamples.get_Bezier_junctions"><code>get_Bezier_junctions</code></a> are fixed for this gradient (interpolation constraint). For the unconstrained gradient, see <a href="#ManoptExamples.grad_L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector, Any, AbstractVector{P}}} where P"><code>grad_L2_acceleration_Bezier</code></a> and set <span>$Œª=0$</span> therein. This gradient is computed using <code>adjoint_Jacobi_field</code>s. For details, see <a href="../references/#BergmannGousenbourger:2018">Bergmann, Gousenbourger, Front. Appl. Math. Stat., 2018</a>. See <a href="#ManoptExamples.de_Casteljau-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}"><code>de_Casteljau</code></a> for more details on the curve.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}}} where P"><code>acceleration_Bezier</code></a>,  <a href="#ManoptExamples.grad_L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector, Any, AbstractVector{P}}} where P"><code>grad_L2_acceleration_Bezier</code></a>, <a href="#ManoptExamples.L2_acceleration_Bezier-Union{Tuple{P}, Tuple{ManifoldsBase.AbstractManifold, AbstractVector{P}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:AbstractFloat}, AbstractFloat, AbstractVector{P}}} where P"><code>L2_acceleration_Bezier</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/BezierCurves.jl#L833-L854">source</a></section></article><h2 id="RiemannianMean"><a class="docs-heading-anchor" href="#RiemannianMean">Riemannian Mean</a><a id="RiemannianMean-1"></a><a class="docs-heading-anchor-permalink" href="#RiemannianMean" title="Permalink"></a></h2><p>See the <a href="../examples/Riemannian-mean/">Riemannian mean example</a> to see these in use.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RiemannianMeanCost" href="#ManoptExamples.RiemannianMeanCost"><code>ManoptExamples.RiemannianMeanCost</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RiemannianMeanCost{P}</code></pre><p>A functor representing the Riemannian center of mass (or Riemannian mean) cost function.</p><p>For a given set of points <span>$d_1,\ldots,d_N$</span> this cost function is defined as</p><p class="math-container">\[f(p) = \sum_{j=i}^N d_{mathcal M}^2(d_i, p),\]</p><p>where <span>$d_{\mathcal M}$</span> is the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.distance-Tuple{AbstractManifold,%20Any,%20Any}"><code>distance</code></a> on a Riemannian manifold.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RiemannianMeanCost(M::AbstractManifold, data::AbstractVector{&lt;:P}) where {P}</code></pre><p>Initialize the cost function to a data set <code>data</code> of points on a manfiold <code>M</code>, where each point is of type <code>P</code>.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.RiemannianMeanGradient!!"><code>RiemannianMeanGradient!!</code></a>, <a href="#ManoptExamples.Riemannian_mean_objective"><code>Riemannian_mean_objective</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RiemannianMean.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RiemannianMeanGradient!!" href="#ManoptExamples.RiemannianMeanGradient!!"><code>ManoptExamples.RiemannianMeanGradient!!</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RiemannianMeanGradient!!{P} where P</code></pre><p>A functor representing the Riemannian center of mass (or Riemannian mean) cost function.</p><p>For a given set of points <span>$d_1,\ldots,d_N$</span> this cost function is defined as</p><p class="math-container">\[\operatorname{grad}f(p) = \sum_{j=i}^N \log_p d_i\]</p><p>where <span>$d_{\mathcal M}$</span> is the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.distance-Tuple{AbstractManifold,%20Any,%20Any}"><code>distance</code></a> on a Riemannian manifold and we employ <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library.html#ManifoldDiff.grad_distance"><code>grad_distance</code></a> to compute the single summands.</p><p>This functor provides both the allocating variant <code>grad_f(M,p)</code> as well as the in-place variant <code>grad_f!(M, X, p)</code> which computes the gradient in-place of <code>X</code>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">RiemannianMeanGradient!!(data::AbstractVector{P}, initial_vector::T=nothing) where {P,T}</code></pre><p>Generate the Riemannian mean gradient based on some data points <code>data</code> an intial tangent vector <code>initial_vector</code>. If you do not provide an initial tangent vector to allocate the intermediate storage of a tangent vector, you can only use the allocating variant.</p><pre><code class="nohighlight hljs">RiemannianMeanGradient!!(
    M::AbstractManifold,
    data::AbstractVector{P};
    initial_vector::T=zero_vector(M, first(data)),
) where {P,T}</code></pre><p>Initialize the Riemannian mean gradient, where the internal storage for tangent vectors can be created automatically, since the Riemannian manifold <code>M</code> is provideed.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.RiemannianMeanCost"><code>RiemannianMeanCost</code></a>, <a href="#ManoptExamples.Riemannian_mean_objective"><code>Riemannian_mean_objective</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RiemannianMean.jl#L33-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.Riemannian_mean_objective" href="#ManoptExamples.Riemannian_mean_objective"><code>ManoptExamples.Riemannian_mean_objective</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Riemannian_mean_objective(data, initial_vector=nothing, evaluation=Manopt.AllocatingEvaluation())
Riemannian_mean_objective(M, data;
initial_vector=zero_vector(M, first(data)),
evaluation=AllocatingEvaluton()
)</code></pre><p>Generate the objective for the Riemannian mean task for some given vector of <code>data</code> points on the Riemannian manifold <code>M</code>.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.RiemannianMeanCost"><code>RiemannianMeanCost</code></a>, <a href="#ManoptExamples.RiemannianMeanGradient!!"><code>RiemannianMeanGradient!!</code></a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The first constructor should only be used if an additional storage of the vector is not feasible, since initialising the <code>initial_vector</code> to <code>nothing</code> disables the in-place variant. Hence the evaluation is a positional argument, since it only can be changed, if a vector is provided.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The objective is available when <code>Manopt.jl</code> is loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RiemannianMean.jl#L91-L112">source</a></section></article><h2 id="RobustPCA"><a class="docs-heading-anchor" href="#RobustPCA">Robust PCA</a><a id="RobustPCA-1"></a><a class="docs-heading-anchor-permalink" href="#RobustPCA" title="Permalink"></a></h2><p>See the <a href="../examples/Robust-PCA/">Robust PCA example</a> to see these in use.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RobustPCACost" href="#ManoptExamples.RobustPCACost"><code>ManoptExamples.RobustPCACost</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RobustPCACost{D,F}</code></pre><p>A functor representing the Riemannian robust PCA function on the <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/grassmann.html">Grassmann</a> manifold. For some given (column) data <span>$D‚àà\mathbb R^{d\times n}$</span> the cost function is defined on some <span>$\operatorname{Gr}(d,m)$</span>, <span>$m&lt;n$</span> as the sum of the distances of the columns <span>$D_i$</span> to the subspace spanned by <span>$p\in\operatorname{Gr}(d,m)$</span> (represented as a point on the Stiefel manifold). The function reads</p><p class="math-container">\[f(U) = \frac{1}{n}\sum_{i=1}^n \lVert pp^{\mathrm{T}}D_i - D_i\rVert\]</p><p>This cost additionally provides a <a href="https://en.wikipedia.org/wiki/Huber_loss">Huber regularisation</a> of the cost, that is for some <span>$Œµ&gt;0$</span> one use <span>$‚Ñì_Œµ(x) = \sqrt{x^2+Œµ^2} - Œµ$</span> in</p><p class="math-container">\[f_{Œµ}(p) = \frac{1}{n}\sum_{i=1}^n ‚Ñì_Œµ\bigl(\lVert pp^{\mathrm{T}}D_i - D_i\rVert\bigr)\]</p><p>Note that this is a mutable struct so you can adapt the <span>$Œµ$</span> later on.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RobustPCACost(data::AbstractMatrix, Œµ=1.0)
RobustPCACost(M::Grassmann, data::AbstractMatrix, Œµ=1.0)</code></pre><p>Initialize the robust PCA cost to some <code>data</code> <span>$D$</span>, and some regularization <span>$Œµ$</span>. The manifold is optional to comply with all examples, but it is not needed here to construct the cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RobustPCA.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RobustPCAGrad!!" href="#ManoptExamples.RobustPCAGrad!!"><code>ManoptExamples.RobustPCAGrad!!</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RobustPCAGrad!!{D,F}</code></pre><p>A functor representing the Riemannian robust PCA gradient on the <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/grassmann.html">Grassmann</a> manifold. For some given (column) data <span>$X‚àà\mathbb R^{p\times n}$</span> the gradient of the <a href="#ManoptExamples.RobustPCACost"><code>RobustPCACost</code></a> can be computed by projecting the Euclidean gradient onto the corresponding tangent space.</p><p>Note that this is a mutable struct so you can adapt the <span>$Œµ$</span> later on.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RobustPCAGrad!!(data, Œµ=1.0)
RobustPCAGrad!!(M::Grassmannian{d,m}, data, Œµ=1.0; evaluation=AllocatingEvaluation())</code></pre><p>Initialize the robust PCA cost to some <code>data</code> <span>$D$</span>, and some regularization <span>$Œµ$</span>. The manifold is optional to comply with all examples, but it is not needed here to construct the cost. Also the <code>evaluation=</code> keyword is present only for unification of the interfaces. Indeed, independent of that keyword the functor always works in both variants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RobustPCA.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.robust_PCA_objective" href="#ManoptExamples.robust_PCA_objective"><code>ManoptExamples.robust_PCA_objective</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">robust_PCA_objective(data::AbstractMatrix, Œµ=1.0; evaluation=AllocatingEvaluation())
robust_PCA_objective(M, data::AbstractMatrix, Œµ=1.0; evaluation=AllocatingEvaluton())</code></pre><p>Generate the objective for the robust PCA task for some given <code>data</code> <span>$D$</span> and Huber regularization parameter <span>$Œµ$</span>.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.RobustPCACost"><code>RobustPCACost</code></a>, <a href="#ManoptExamples.RobustPCAGrad!!"><code>RobustPCAGrad!!</code></a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since the construction is independent of the manifold, that argument is optional and mainly provided to comply with other objectives. Similarly, independent of the <code>evaluation</code>, indeed the gradient always allows for both the allocating and the in-place variant to be used, though that keyword is used to setup the objective.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The objective is available when <code>Manopt.jl</code> is loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/RobustPCA.jl#L98-L117">source</a></section></article><h2 id="Rosenbrock"><a class="docs-heading-anchor" href="#Rosenbrock">Rosenbrock Function</a><a id="Rosenbrock-1"></a><a class="docs-heading-anchor-permalink" href="#Rosenbrock" title="Permalink"></a></h2><p>See the <a href="../examples/Rosenbrock/">Rosenbrock example</a>  and <a href="../examples/Difference-of-Convex-Rosenbrock/">The Difference of Convex Rosenbrock Example</a> to see these in use.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RosenbrockCost" href="#ManoptExamples.RosenbrockCost"><code>ManoptExamples.RosenbrockCost</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RosenbrockCost</code></pre><p>Provide the Rosenbrock function in 2D, i.e. for some <span>$a,b ‚àà ‚Ñù$</span></p><p class="math-container">\[f(\mathcal M, p) = a(p_1^2-p_2)^2 + (p_1-b)^2\]</p><p>which means that for the 2D case, the manifold <span>$\mathcal M$</span> is ignored.</p><p>See also <a href="https://en.wikipedia.org/wiki/Rosenbrock_function">üìñ Rosenbrock</a> (with slightly different parameter naming).</p><p><strong>Constructor</strong></p><p>f = Rosenbrock(a,b)</p><p>generates the struct/function of the Rosenbrock cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RosenbrockGradient!!" href="#ManoptExamples.RosenbrockGradient!!"><code>ManoptExamples.RosenbrockGradient!!</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RosenbrockGradient</code></pre><p>Provide Euclidean gradient fo the Rosenbrock function in 2D, i.e. for some <span>$a,b ‚àà ‚Ñù$</span></p><p class="math-container">\[\nabla f(\mathcal M, p) = \begin{pmatrix}
    4a(p_1^2-p_2)p_1 + 2(p_1-b) \\
    -2a(p_1^2-p_2)
\end{pmatrix}\]</p><p>i.e. also here the manifold is ignored.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RosenbrockGradient(a,b)</code></pre><p><strong>Functors</strong></p><pre><code class="nohighlight hljs">grad_f!!(M,p)
grad_f!!(M, X, p)</code></pre><p>evaluate the gradient at <span>$p$</span> the manifold<span>$\mathcal M$</span> is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L42-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.RosenbrockMetric" href="#ManoptExamples.RosenbrockMetric"><code>ManoptExamples.RosenbrockMetric</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RosenbrockMetric &lt;: AbstractMetric</code></pre><p>A metric related to the Rosenbrock problem, where the metric at a point <span>$p‚àà\mathbb R^2$</span> is given by</p><p class="math-container">\[‚ü®X,Y‚ü©_{\mathrm{Rb},p} = X^\mathrm{T}G_pY, \qquad
G_p = \begin{pmatrix}
  1+4p_{1}^2 &amp; -2p_{1} \\
  -2p_{1} &amp; 1
\end{pmatrix},\]</p><p>where the <span>$\mathrm{Rb}$</span> stands for Rosenbrock</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L102-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any, Any}" href="#Base.log-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any, Any}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = log(::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, p, q)
log!(::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, X, p, q)</code></pre><p>Compute the logarithmic map with respect to the <a href="#ManoptExamples.RosenbrockMetric"><code>RosenbrockMetric</code></a>. The formula reads for any <span>$j ‚àà \{1,‚Ä¶,m\}$</span></p><p class="math-container">\[X = \begin{pmatrix}
  q_1 - p_1 \\
  q_2 - p_2 + (q_1 - p_1)^2
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L276-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.inverse_local_metric-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any}" href="#Manifolds.inverse_local_metric-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any}"><code>Manifolds.inverse_local_metric</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inverse_local_metric(::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, p)</code></pre><p>Return the inverse of the local metric matrix of the <a href="#ManoptExamples.RosenbrockMetric"><code>RosenbrockMetric</code></a> in the canonical unit vector basis of the tangent space <span>$T_p\mathbb R^2$</span> given as</p><p class="math-container">\[G^{-1}_p =
\begin{pmatrix}
    1 &amp; 2p_1\\
    2p_1 &amp; 1+4p_1^2 \\
\end{pmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L205-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.local_metric-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any}" href="#Manifolds.local_metric-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any}"><code>Manifolds.local_metric</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_metric(::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, p)</code></pre><p>Return the local metric matrix of the <a href="#ManoptExamples.RosenbrockMetric"><code>RosenbrockMetric</code></a> in the canonical unit vector basis of the tangent space <span>$T_p\mathbb R^2$</span> given as</p><p class="math-container">\[G_p = \begin{pmatrix}
  1+4p_1^2 &amp; -2p_1 \\
  -2p_1 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L254-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.change_representer-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, ManifoldsBase.EuclideanMetric, Any, Any}" href="#ManifoldsBase.change_representer-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, ManifoldsBase.EuclideanMetric, Any, Any}"><code>ManifoldsBase.change_representer</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = change_representer(M::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, ::EuclideanMetric, p, X)
change_representer!(M::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, Y, ::EuclideanMetric, p, X)</code></pre><p>Given the Euclidean gradient <code>X</code> at <code>p</code>, this function computes the corresponding Riesz representer <code>Y</code><code>such that</code><code>‚ü®X,Z‚ü© = ‚ü® Y, Z ‚ü©_{\mathrm{Rb},p}</code><code>holds for all</code><code>Z</code><code>, in other words</code><code>Y = G(p)^{-1}X</code>`.</p><p>this function is used in <code>riemannian_gradient</code> to convert a Euclidean into a Riemannian gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inner(M::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, p, X, Y)</code></pre><p>Compute the inner product on <span>$\mathbb R^2$</span> with respect to the <a href="#ManoptExamples.RosenbrockMetric"><code>RosenbrockMetric</code></a>, i.e. for <span>$X,Y \in T_p\mathcal M$</span> we have</p><p class="math-container">\[‚ü®X,Y‚ü©_{\mathrm{Rb},p} = X^\mathrm{T}G_pY, \qquad
G_p = \begin{pmatrix}
  1+4p_1^2 &amp; -2p_1\\
  -2p_1 &amp; 1
\end{pmatrix},\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L229-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.Rosenbrock_objective" href="#ManoptExamples.Rosenbrock_objective"><code>ManoptExamples.Rosenbrock_objective</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rosenbrock_objective(M::AbstractManifold=DefaultManifold(), a=100.0, b=1.0, evaluation=AllocatingEvaluation())</code></pre><p>Return the gradient objective of the Rosenbrock example.</p><p>See also <a href="#ManoptExamples.RosenbrockCost"><code>RosenbrockCost</code></a>, <a href="#ManoptExamples.RosenbrockGradient!!"><code>RosenbrockGradient!!</code></a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The objective is available when <code>Manopt.jl</code> is loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L88-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.expt-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any, Any, Number}" href="#ManoptExamples.expt-Tuple{Manifolds.MetricManifold{‚Ñù, &lt;:Manifolds.Euclidean{&lt;:Union{ManifoldsBase.TypeParameter{Tuple{2}}, Tuple{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Int64}, ‚Ñù}, ManoptExamples.RosenbrockMetric}, Any, Any, Number}"><code>ManoptExamples.expt</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q = exp(::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, p, X)
exp!(::MetricManifold{‚Ñù,Euclidean{Tuple{2},‚Ñù},RosenbrockMetric}, q, p, X)</code></pre><p>Compute the exponential map with respect to the <a href="#ManoptExamples.RosenbrockMetric"><code>RosenbrockMetric</code></a>.</p><p class="math-container">\[    q = \begin{pmatrix} p_1 + X_1 \\ p_2+X_2+X_1^2\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.minimizer-Tuple{ManoptExamples.RosenbrockCost}" href="#ManoptExamples.minimizer-Tuple{ManoptExamples.RosenbrockCost}"><code>ManoptExamples.minimizer</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimizer(::RosenbrockCost)</code></pre><p>Return the minimizer of the <a href="#ManoptExamples.RosenbrockCost"><code>RosenbrockCost</code></a>, which is given by</p><p class="math-container">\[p^* = \begin{pmatrix} b\\b^2 \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/Rosenbrock.jl#L31-L39">source</a></section></article><h2 id="Total-Variation"><a class="docs-heading-anchor" href="#Total-Variation">Total Variation</a><a id="Total-Variation-1"></a><a class="docs-heading-anchor-permalink" href="#Total-Variation" title="Permalink"></a></h2><p>See the <a href="../examples/Total-Variation/">Total Variation example</a> to see these in use.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.Intrinsic_infimal_convolution_TV12-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any, 5}}" href="#ManoptExamples.Intrinsic_infimal_convolution_TV12-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any, 5}}"><code>ManoptExamples.Intrinsic_infimal_convolution_TV12</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Intrinsic_infimal_convolution_TV12(M, f, u, v, Œ±, Œ≤)</code></pre><p>Compute the intrinsic infimal convolution model, where the addition is replaced by a mid point approach and the two functions involved are <a href="#ManoptExamples.second_order_Total_Variation"><code>second_order_Total_Variation</code></a> and <a href="#ManoptExamples.Total_Variation"><code>Total_Variation</code></a>. The model reads</p><p class="math-container">\[E(u,v) =
  \frac{1}{2}\sum_{i ‚àà \mathcal G}
    d_{\mathcal M}\bigl(g(\frac{1}{2},v_i,w_i),f_i\bigr)
  +\alpha\bigl( Œ≤\mathrm{TV}(v) + (1-Œ≤)\mathrm{TV}_2(w) \bigr).\]</p><p>for more details see [<a href="../references/#BergmannFitschenPerschSteidl:2017">BFPS17</a>, <a href="../references/#BergmannFitschenPerschSteidl:2018">BFPS18</a>].</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.Total_Variation"><code>Total_Variation</code></a>, <a href="#ManoptExamples.second_order_Total_Variation"><code>second_order_Total_Variation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L6-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.L2_Total_Variation-NTuple{4, Any}" href="#ManoptExamples.L2_Total_Variation-NTuple{4, Any}"><code>ManoptExamples.L2_Total_Variation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2_Total_Variation(M, p_data, Œ±, p)</code></pre><p>compute the <span>$‚Ñì^2$</span>-TV functional on the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#sec-power-manifold">PowerManifold</a> <code>M</code> for given (fixed) data <code>p_data</code> (on <code>M</code>), a nonnegative weight <code>Œ±</code>, and evaluated at <code>p</code> (on <code>M</code>), i.e.</p><p class="math-container">\[E(p) = d_{\mathcal M}^2(f,p) + \alpha \operatorname{TV}(p)\]</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.Total_Variation"><code>Total_Variation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L32-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.L2_Total_Variation_1_2-Tuple{ManifoldsBase.PowerManifold, Vararg{Any, 4}}" href="#ManoptExamples.L2_Total_Variation_1_2-Tuple{ManifoldsBase.PowerManifold, Vararg{Any, 4}}"><code>ManoptExamples.L2_Total_Variation_1_2</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2_Total_Variation_1_2(M, f, Œ±, Œ≤, x)</code></pre><p>compute the <span>$‚Ñì^2$</span>-TV-TV2 functional on the <code>PowerManifold</code> manifold <code>M</code> for given (fixed) data <code>f</code> (on <code>M</code>), nonnegative weight <code>Œ±</code>, <code>Œ≤</code>, and evaluated at <code>x</code> (on <code>M</code>), i.e.</p><p class="math-container">\[E(x) = d_{\mathcal M}^2(f,x) + \alpha\operatorname{TV}(x)
  + Œ≤\operatorname{TV}_2(x)\]</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.Total_Variation"><code>Total_Variation</code></a>, <a href="#ManoptExamples.second_order_Total_Variation"><code>second_order_Total_Variation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L51-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.L2_second_order_Total_Variation-Tuple{ManifoldsBase.PowerManifold, Any, Any, Any}" href="#ManoptExamples.L2_second_order_Total_Variation-Tuple{ManifoldsBase.PowerManifold, Any, Any, Any}"><code>ManoptExamples.L2_second_order_Total_Variation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2_second_order_Total_Variation(M, f, Œ≤, x)</code></pre><p>compute the <span>$‚Ñì^2$</span>-TV2 functional on the <code>PowerManifold</code> manifold <code>M</code> for given data <code>f</code>, nonnegative parameter <code>Œ≤</code>, and evaluated at <code>x</code>, i.e.</p><p class="math-container">\[E(x) = d_{\mathcal M}^2(f,x) + Œ≤\operatorname{TV}_2(x)\]</p><p>as used in [<a href="../references/#BacakBergmannSteidlWeinmann:2016">BBSW16</a>].</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.second_order_Total_Variation"><code>second_order_Total_Variation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L73-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.Total_Variation" href="#ManoptExamples.Total_Variation"><code>ManoptExamples.Total_Variation</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Total_Variation(M,x [,p=2,q=1])</code></pre><p>Compute the <span>$\operatorname{TV}^p$</span> functional for data <code>x</code>on the <code>PowerManifold</code> manifold <code>M</code>, i.e. <span>$\mathcal M = \mathcal N^n$</span>, where <span>$n ‚àà \mathbb N^k$</span> denotes the dimensions of the data <code>x</code>. Let <span>$\mathcal I_i$</span> denote the forward neighbors, i.e. with <span>$\mathcal G$</span> as all indices from <span>$\mathbf{1} ‚àà \mathbb N^k$</span> to <span>$n$</span> we have <span>$\mathcal I_i = \{i+e_j, j=1,‚Ä¶,k\}\cap \mathcal G$</span>. The formula reads</p><p class="math-container">\[E^q(x) = \sum_{i ‚àà \mathcal G}
  \bigl( \sum_{j ‚àà  \mathcal I_i} d^p_{\mathcal M}(x_i,x_j) \bigr)^{q/p},\]</p><p>see [<a href="../references/#WeinmannDemaretStorath:2014">WDS14</a>] for more details. In long function names, this might be shortened to <code>TV1</code> and the <code>1</code> might be ommitted if only total variation is present.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.grad_Total_Variation"><code>grad_Total_Variation</code></a>, <a href="#ManoptExamples.prox_Total_Variation"><code>prox_Total_Variation</code></a>, <a href="#ManoptExamples.second_order_Total_Variation"><code>second_order_Total_Variation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L93-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.adjoint_differential_forward_logs-Union{Tuple{TPR}, Tuple{TSize}, Tuple{TM}, Tuple{ùîΩ}, Tuple{ManifoldsBase.PowerManifold{ùîΩ, TM, TSize, TPR}, Any, Any}} where {ùîΩ, TM, TSize, TPR}" href="#ManoptExamples.adjoint_differential_forward_logs-Union{Tuple{TPR}, Tuple{TSize}, Tuple{TM}, Tuple{ùîΩ}, Tuple{ManifoldsBase.PowerManifold{ùîΩ, TM, TSize, TPR}, Any, Any}} where {ùîΩ, TM, TSize, TPR}"><code>ManoptExamples.adjoint_differential_forward_logs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = adjoint_differential_forward_logs(M, p, X)
adjoint_differential_forward_logs!(M, Y, p, X)</code></pre><p>Compute the adjoint differential of <a href="#ManoptExamples.forward_logs-Union{Tuple{TPR}, Tuple{TSize}, Tuple{TM}, Tuple{ùîΩ}, Tuple{ManifoldsBase.PowerManifold{ùîΩ, TM, TSize, TPR}, Any}} where {ùîΩ, TM, TSize, TPR}"><code>forward_logs</code></a> <span>$F$</span> occurring, in the power manifold array <code>p</code>, the differential of the function</p><p><span>$F_i(p) = \sum_{j ‚àà \mathcal I_i} \log_{p_i} p_j$</span></p><p>where <span>$i$</span> runs over all indices of the <code>PowerManifold</code> manifold <code>M</code> and <span>$\mathcal I_i$</span> denotes the forward neighbors of <span>$i$</span> Let <span>$n$</span> be the number dimensions of the <code>PowerManifold</code> manifold (i.e. <code>length(size(x)</code>)). Then the input tangent vector lies on the manifold <span>$\mathcal M&#39; = \mathcal M^n$</span>. The adjoint differential can be computed in place of <code>Y</code>.</p><p><strong>Input</strong></p><ul><li><code>M</code>     ‚Äì a <code>PowerManifold</code> manifold</li><li><code>p</code>     ‚Äì an array of points on a manifold</li><li><code>X</code>     ‚Äì a tangent vector to from the n-fold power of <code>p</code>, where n is the <code>ndims</code> of <code>p</code></li></ul><p><strong>Output</strong></p><p><code>Y</code> ‚Äì resulting tangent vector in <span>$T_p\mathcal M$</span> representing the adjoint   differentials of the logs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L1275-L1300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.differential_forward_logs-Tuple{ManifoldsBase.PowerManifold, Any, Any}" href="#ManoptExamples.differential_forward_logs-Tuple{ManifoldsBase.PowerManifold, Any, Any}"><code>ManoptExamples.differential_forward_logs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = differential_forward_logs(M, p, X)
differential_forward_logs!(M, Y, p, X)</code></pre><p>compute the differential of <a href="#ManoptExamples.forward_logs-Union{Tuple{TPR}, Tuple{TSize}, Tuple{TM}, Tuple{ùîΩ}, Tuple{ManifoldsBase.PowerManifold{ùîΩ, TM, TSize, TPR}, Any}} where {ùîΩ, TM, TSize, TPR}"><code>forward_logs</code></a> <span>$F$</span> on the <code>PowerManifold</code> manifold <code>M</code> at <code>p</code> and direction <code>X</code> , in the power manifold array, the differential of the function</p><p class="math-container">\[F_i(x) = \sum_{j ‚àà \mathcal I_i} \log_{p_i} p_j, \quad i ‚àà \mathcal G,\]</p><p>where <span>$\mathcal G$</span> is the set of indices of the <code>PowerManifold</code> manifold <code>M</code> and <span>$\mathcal I_i$</span> denotes the forward neighbors of <span>$i$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code>     ‚Äì a <code>PowerManifold</code> manifold</li><li><code>p</code>     ‚Äì a point.</li><li><code>X</code>     ‚Äì a tangent vector.</li></ul><p><strong>Output</strong></p><ul><li><code>Y</code> ‚Äì resulting tangent vector in <span>$T_x\mathcal N$</span> representing the differentials of the   logs, where <span>$\mathcal N$</span> is the power manifold with the number of dimensions added   to <code>size(x)</code>. The computation can also be done in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L1336-L1359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.forward_logs-Union{Tuple{TPR}, Tuple{TSize}, Tuple{TM}, Tuple{ùîΩ}, Tuple{ManifoldsBase.PowerManifold{ùîΩ, TM, TSize, TPR}, Any}} where {ùîΩ, TM, TSize, TPR}" href="#ManoptExamples.forward_logs-Union{Tuple{TPR}, Tuple{TSize}, Tuple{TM}, Tuple{ùîΩ}, Tuple{ManifoldsBase.PowerManifold{ùîΩ, TM, TSize, TPR}, Any}} where {ùîΩ, TM, TSize, TPR}"><code>ManoptExamples.forward_logs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = forward_logs(M,x)
forward_logs!(M, Y, x)</code></pre><p>compute the forward logs <span>$F$</span> (generalizing forward differences) occurring, in the power manifold array, the function</p><p class="math-container">\[F_i(x) = \sum_{j ‚àà \mathcal I_i} \log_{x_i} x_j,\quad i  ‚àà  \mathcal G,\]</p><p>where <span>$\mathcal G$</span> is the set of indices of the <code>PowerManifold</code> manifold <code>M</code> and <span>$\mathcal I_i$</span> denotes the forward neighbors of <span>$i$</span>. This can also be done in place of <code>Œæ</code>.</p><p><strong>Input</strong></p><ul><li><code>M</code> ‚Äì a <code>PowerManifold</code> manifold</li><li><code>x</code> ‚Äì a point.</li></ul><p><strong>Output</strong></p><ul><li><code>Y</code> ‚Äì resulting tangent vector in <span>$T_x\mathcal M$</span> representing the logs, where <span>$\mathcal N$</span> is the power manifold with the number of dimensions added to <code>size(x)</code>. The computation can be done in place of <code>Y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L1191-L1213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.grad_Total_Variation" href="#ManoptExamples.grad_Total_Variation"><code>ManoptExamples.grad_Total_Variation</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = grad_Total_Variation(M, Œª, x[, p=1])
grad_Total_Variation!(M, X, Œª, x[, p=1])</code></pre><p>Compute the (sub)gradient <span>$‚àÇf$</span> of all forward differences occurring, in the power manifold array, i.e. of the function</p><p class="math-container">\[f(p) = \sum_{i}\sum_{j ‚àà \mathcal I_i} d^p(x_i,x_j)\]</p><p>where <span>$i$</span> runs over all indices of the <code>PowerManifold</code> manifold <code>M</code> and <span>$\mathcal I_i$</span> denotes the forward neighbors of <span>$i$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> ‚Äì a <code>PowerManifold</code> manifold</li><li><code>x</code> ‚Äì a point.</li></ul><p><strong>Output</strong></p><ul><li>X ‚Äì resulting tangent vector in <span>$T_x\mathcal M$</span>. The computation can also be done in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L291-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.grad_Total_Variation-Union{Tuple{T}, Tuple{ManifoldsBase.AbstractManifold, Tuple{T, T}}, Tuple{ManifoldsBase.AbstractManifold, Tuple{T, T}, Any}} where T" href="#ManoptExamples.grad_Total_Variation-Union{Tuple{T}, Tuple{ManifoldsBase.AbstractManifold, Tuple{T, T}}, Tuple{ManifoldsBase.AbstractManifold, Tuple{T, T}, Any}} where T"><code>ManoptExamples.grad_Total_Variation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = grad_Total_Variation(M, (x,y)[, p=1])
grad_Total_Variation!(M, X, (x,y)[, p=1])</code></pre><p>compute the (deterministic) (sub) gradient of <span>$\frac{1}{p}d^p_{\mathcal M}(x,y)$</span> with respect to both <span>$x$</span> and <span>$y$</span> (in place of <code>X</code> and <code>Y</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L254-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.grad_intrinsic_infimal_convolution_TV12-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any, 5}}" href="#ManoptExamples.grad_intrinsic_infimal_convolution_TV12-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any, 5}}"><code>ManoptExamples.grad_intrinsic_infimal_convolution_TV12</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad_u, grad_v = grad_intrinsic_infimal_convolution_TV12(M, f, u, v, Œ±, Œ≤)</code></pre><p>compute (sub)gradient of the intrinsic infimal convolution model using the mid point model of second order differences, see <a href="#ManoptExamples.second_order_Total_Variation"><code>second_order_Total_Variation</code></a>, i.e. for some <span>$f ‚àà \mathcal M$</span> on a <code>PowerManifold</code> manifold <span>$\mathcal M$</span> this function computes the (sub)gradient of</p><p class="math-container">\[E(u,v) =
\frac{1}{2}\sum_{i ‚àà \mathcal G} d_{\mathcal M}(g(\frac{1}{2},v_i,w_i),f_i)
+ \alpha
\bigl(
Œ≤\mathrm{TV}(v) + (1-Œ≤)\mathrm{TV}_2(w)
\bigr),\]</p><p>where both total variations refer to the intrinsic ones, <a href="#ManoptExamples.grad_Total_Variation"><code>grad_Total_Variation</code></a> and <a href="#ManoptExamples.grad_second_order_Total_Variation"><code>grad_second_order_Total_Variation</code></a>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L226-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.grad_second_order_Total_Variation" href="#ManoptExamples.grad_second_order_Total_Variation"><code>ManoptExamples.grad_second_order_Total_Variation</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad_second_order_Total_Variation(M::PowerManifold, q[, p=1])</code></pre><p>computes the (sub) gradient of <span>$\frac{1}{p}d_2^p(q_1,q_2,q_3)$</span> with respect to all <span>$q_1,q_2,q_3$</span> occurring along any array dimension in the point <code>q</code>, where <code>M</code> is the corresponding <code>PowerManifold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L562-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.grad_second_order_Total_Variation" href="#ManoptExamples.grad_second_order_Total_Variation"><code>ManoptExamples.grad_second_order_Total_Variation</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = grad_second_order_Total_Variation(M, q[, p=1])
grad_second_order_Total_Variation!(M, Y, q[, p=1])</code></pre><p>computes the (sub) gradient of <span>$\frac{1}{p}d_2^p(q_1, q_2, q_3)$</span> with respect to all three components of <span>$q‚àà\mathcal M^3$</span>, where <span>$d_2$</span> denotes the second order absolute difference using the mid point model, i.e. let</p><p class="math-container">\[\mathcal C = \bigl\{ c ‚àà \mathcal M \ |\ g(\tfrac{1}{2};q_1,q_3) \text{ for some geodesic }g\bigr\}\]</p><p>denote the mid points between <span>$q_1$</span> and <span>$q_3$</span> on the manifold <span>$\mathcal M$</span>. Then the absolute second order difference is defined as</p><p class="math-container">\[d_2(q_1,q_2,q_3) = \min_{c ‚àà \mathcal C_{q_1,q_3}} d(c, q_2).\]</p><p>While the (sub)gradient with respect to <span>$q_2$</span> is easy, the other two require the evaluation of an <code>adjoint_Jacobi_field</code>.</p><p>The derivation of this gradient can be found in [<a href="../references/#BacakBergmannSteidlWeinmann:2016">BBSW16</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L504-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.project_collaborative_TV" href="#ManoptExamples.project_collaborative_TV"><code>ManoptExamples.project_collaborative_TV</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project_collaborative_TV(M, Œª, x, Œû[, p=2,q=1])
project_collaborative_TV!(M, Œò, Œª, x, Œû[, p=2,q=1])</code></pre><p>compute the projection onto collaborative Norm unit (or Œ±-) ball, i.e. of the function</p><p class="math-container">\[F^q(x) = \sum_{i‚àà\mathcal G}
  \Bigl( \sum_{j‚àà\mathcal I_i}
    \sum_{k=1}^d \lVert X_{i,j}\rVert_x^p\Bigr)^\frac{q}{p},\]</p><p>where <span>$\mathcal G$</span> is the set of indices for <span>$x‚àà\mathcal M$</span> and <span>$\mathcal I_i$</span> is the set of its forward neighbors. The computation can also be done in place of <code>Œò</code>.</p><p>This is adopted from the paper <a href="../references/#DuranMoelleSbertCremers:2016">Duran, M√∂ller, Sbert, Cremers, SIAM J Imag Sci, 2016</a>, see their Example 3 for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L1040-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.prox_Total_Variation" href="#ManoptExamples.prox_Total_Variation"><code>ManoptExamples.prox_Total_Variation</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Œæ = prox_Total_Variation(M,Œª,x [,p=1])</code></pre><p>compute the proximal maps <span>$\operatorname{prox}_{Œª\varphi}$</span> of all forward differences occurring in the power manifold array, i.e. <span>$\varphi(xi,xj) = d_{\mathcal M}^p(xi,xj)$</span> with <code>xi</code> and <code>xj</code> are array elements of <code>x</code> and <code>j = i+e_k</code>, where <code>e_k</code> is the <span>$k$</span>th unit vector. The parameter <code>Œª</code> is the prox parameter.</p><p><strong>Input</strong></p><ul><li><code>M</code> ‚Äì a manifold <code>M</code></li><li><code>Œª</code> ‚Äì a real value, parameter of the proximal map</li><li><code>x</code> ‚Äì a point.</li></ul><p><strong>Optional</strong></p><p>(default is given in brackets)</p><ul><li><code>p</code> ‚Äì (1) exponent of the distance of the TV term</li></ul><p><strong>Output</strong></p><ul><li><code>y</code> ‚Äì resulting  point containing with all mentioned proximal points evaluated (in a cyclic order). The computation can also be done in place</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L673-L694">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.prox_Total_Variation-Union{Tuple{T}, Tuple{ManifoldsBase.AbstractManifold, Number, Tuple{T, T}}, Tuple{ManifoldsBase.AbstractManifold, Number, Tuple{T, T}, Int64}} where T" href="#ManoptExamples.prox_Total_Variation-Union{Tuple{T}, Tuple{ManifoldsBase.AbstractManifold, Number, Tuple{T, T}}, Tuple{ManifoldsBase.AbstractManifold, Number, Tuple{T, T}, Int64}} where T"><code>ManoptExamples.prox_Total_Variation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">[y1,y2] = prox_Total_Variation(M, Œª, [x1,x2] [,p=1])
prox_Total_Variation!(M, [y1,y2] Œª, [x1,x2] [,p=1])</code></pre><p>Compute the proximal map <span>$\operatorname{prox}_{Œª\varphi}$</span> of <span>$œÜ(x,y) = d_{\mathcal M}^p(x,y)$</span> with parameter <code>Œª</code>. A derivation of this closed form solution is given in see [<a href="../references/#WeinmannDemaretStorath:2014">WDS14</a>].</p><p><strong>Input</strong></p><ul><li><code>M</code> ‚Äì a manifold <code>M</code></li><li><code>Œª</code> ‚Äì a real value, parameter of the proximal map</li><li><code>(x1,x2)</code> ‚Äì a tuple of two points,</li></ul><p><strong>Optional</strong></p><p>(default is given in brackets)</p><ul><li><code>p</code> ‚Äì (1) exponent of the distance of the TV term</li></ul><p><strong>Output</strong></p><ul><li><code>(y1,y2)</code> ‚Äì resulting tuple of points of the <span>$\operatorname{prox}_{ŒªœÜ}($</span><code>(x1,x2)</code><span>$)$</span>. The result can also be computed in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L607-L631">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.prox_parallel_TV" href="#ManoptExamples.prox_parallel_TV"><code>ManoptExamples.prox_parallel_TV</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">y = prox_parallel_TV(M, Œª, x [,p=1])
prox_parallel_TV!(M, y, Œª, x [,p=1])</code></pre><p>compute the proximal maps <span>$\operatorname{prox}_{ŒªœÜ}$</span> of all forward differences occurring in the power manifold array, i.e. <span>$œÜ(x_i,x_j) = d_{\mathcal M}^p(x_i,x_j)$</span> with <code>xi</code> and <code>xj</code> are array elements of <code>x</code> and <code>j = i+e_k</code>, where <code>e_k</code> is the <span>$k$</span>th unit vector. The parameter <code>Œª</code> is the prox parameter.</p><p><strong>Input</strong></p><ul><li><code>M</code>     ‚Äì a <code>PowerManifold</code> manifold</li><li><code>Œª</code>     ‚Äì a real value, parameter of the proximal map</li><li><code>x</code>     ‚Äì a point</li></ul><p><strong>Optional</strong></p><p>(default is given in brackets)</p><ul><li><code>p</code> ‚Äì (<code>1</code>) exponent of the distance of the TV term</li></ul><p><strong>Output</strong></p><ul><li><code>y</code>  ‚Äì resulting Array of points with all mentioned proximal points evaluated (in a parallel within the arrays elements). The computation can also be done in place.</li></ul><p><em>See also</em> <a href="#ManoptExamples.prox_Total_Variation"><code>prox_Total_Variation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L740-L765">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.prox_second_order_Total_Variation" href="#ManoptExamples.prox_second_order_Total_Variation"><code>ManoptExamples.prox_second_order_Total_Variation</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(y1,y2,y3) = prox_second_order_Total_Variation(M,Œª,(x1,x2,x3),[p=1], kwargs...)
prox_second_order_Total_Variation!(M, y, Œª,(x1,x2,x3),[p=1], kwargs...)</code></pre><p>Compute the proximal map <span>$\operatorname{prox}_{Œª\varphi}$</span> of <span>$\varphi(x_1,x_2,x_3) = d_{\mathcal M}^p(c(x_1,x_3),x_2)$</span> with parameter <code>Œª</code>&gt;0, where <span>$c(x,z)$</span> denotes the mid point of a shortest geodesic from <code>x1</code> to <code>x3</code> that is closest to <code>x2</code>. The result can be computed in place of <code>y</code>.</p><p>Note that this function does not have a closed form solution but is solbed by a few steps of the <a href="https://manoptjl.org/stable/solvers/subgradient/">subgradient mehtod</a> from <a href>manopt.jl</a> by default. See [<a href="../references/#BacakBergmannSteidlWeinmann:2016">BBSW16</a>] for a derivation.</p><p><strong>Input</strong></p><ul><li><p><code>M</code>          ‚Äì a manifold</p></li><li><p><code>Œª</code>          ‚Äì a real value, parameter of the proximal map</p></li><li><p><code>(x1,x2,x3)</code> ‚Äì a tuple of three points</p></li><li><p><code>p</code> ‚Äì (<code>1</code>) exponent of the distance of the TV term</p></li></ul><p><strong>Optional</strong></p><p><code>kwargs...</code> ‚Äì parameters for the internal <a href="https://manoptjl.org/stable/solvers/subgradient/#Manopt.subgradient_method"><code>subgradient_method</code></a>     (if <code>M</code> is neither <code>Euclidean</code> nor <code>Circle</code>, since for these a closed form     is given)</p><p><strong>Output</strong></p><ul><li><p><code>(y1,y2,y3)</code> ‚Äì resulting tuple of points of the proximal map. The computation can also be done in place.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>This function requires <code>Manopt.jl</code> to be loaded</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L843-L876">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.prox_second_order_Total_Variation-Union{Tuple{T}, Tuple{N}, Tuple{ManifoldsBase.PowerManifold{N, T}, Any, Any}, Tuple{ManifoldsBase.PowerManifold{N, T}, Any, Any, Int64}} where {N, T}" href="#ManoptExamples.prox_second_order_Total_Variation-Union{Tuple{T}, Tuple{N}, Tuple{ManifoldsBase.PowerManifold{N, T}, Any, Any}, Tuple{ManifoldsBase.PowerManifold{N, T}, Any, Any, Int64}} where {N, T}"><code>ManoptExamples.prox_second_order_Total_Variation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">y = prox_second_order_Total_Variation(M, Œª, x[, p=1])
prox_second_order_Total_Variation!(M, y, Œª, x[, p=1])</code></pre><p>compute the proximal maps <span>$\operatorname{prox}_{Œª\varphi}$</span> of all centered second order differences occurring in the power manifold array, i.e. <span>$\varphi(x_k,x_i,x_j) = d_2(x_k,x_i.x_j)$</span>, where <span>$k,j$</span> are backward and forward neighbors (along any dimension in the array of <code>x</code>). The parameter <code>Œª</code> is the prox parameter.</p><p><strong>Input</strong></p><ul><li><code>M</code> ‚Äì a manifold <code>M</code></li><li><code>Œª</code> ‚Äì a real value, parameter of the proximal map</li><li><code>x</code> ‚Äì a points.</li></ul><p><strong>Optional</strong></p><p>(default is given in brackets)</p><ul><li><code>p</code> ‚Äì (<code>1</code>) exponent of the distance of the TV term</li></ul><p><strong>Output</strong></p><ul><li><code>y</code> ‚Äì resulting point with all mentioned proximal points evaluated (in a cyclic order). The computation can also be done in place.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function requires <code>Manopt.jl</code> to be loaded</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L879-L904">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.second_order_Total_Variation" href="#ManoptExamples.second_order_Total_Variation"><code>ManoptExamples.second_order_Total_Variation</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">second_order_Total_Variation(M,x [,p=1])</code></pre><p>compute the <span>$\operatorname{TV}_2^p$</span> functional for data <code>x</code> on the <code>PowerManifold</code> manifold <code>M</code>, i.e. <span>$\mathcal M = \mathcal N^n$</span>, where <span>$n ‚àà \mathbb N^k$</span> denotes the dimensions of the data <code>x</code>. Let <span>$\mathcal I_i^{\pm}$</span> denote the forward and backward neighbors, respectively, i.e. with <span>$\mathcal G$</span> as all indices from <span>$\mathbf{1} ‚àà \mathbb N^k$</span> to <span>$n$</span> we have <span>$\mathcal I^\pm_i = \{i\pm e_j, j=1,‚Ä¶,k\}\cap \mathcal I$</span>. The formula then reads</p><p class="math-container">\[E(x) = \sum_{i ‚àà \mathcal I,\ j_1 ‚àà  \mathcal I^+_i,\ j_2 ‚àà  \mathcal I^-_i}
d^p_{\mathcal M}(c_i(x_{j_1},x_{j_2}), x_i),\]</p><p>where <span>$c_i(‚ãÖ,‚ãÖ)$</span> denotes the mid point between its two arguments that is nearest to <span>$x_i$</span>, see [<a href="../references/#BacakBergmannSteidlWeinmann:2016">BBSW16</a>] for a derivation.</p><p>In long function names, this might be shortened to <code>TV2</code>.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.grad_second_order_Total_Variation"><code>grad_second_order_Total_Variation</code></a>, <a href="#ManoptExamples.prox_second_order_Total_Variation"><code>prox_second_order_Total_Variation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L170-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.second_order_Total_Variation-Union{Tuple{T}, Tuple{MT}, Tuple{MT, Tuple{T, T, T}}, Tuple{MT, Tuple{T, T, T}, Any}} where {MT&lt;:ManifoldsBase.AbstractManifold, T}" href="#ManoptExamples.second_order_Total_Variation-Union{Tuple{T}, Tuple{MT}, Tuple{MT, Tuple{T, T, T}}, Tuple{MT, Tuple{T, T, T}, Any}} where {MT&lt;:ManifoldsBase.AbstractManifold, T}"><code>ManoptExamples.second_order_Total_Variation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">second_order_Total_Variation(M,(x1,x2,x3) [,p=1])</code></pre><p>Compute the <span>$\operatorname{TV}_2^p$</span> functional for the 3-tuple of points <code>(x1,x2,x3)</code>on the manifold <code>M</code>. Denote by</p><p class="math-container">\[  \mathcal C = \bigl\{ c ‚àà  \mathcal M \ |\ g(\tfrac{1}{2};x_1,x_3) \text{ for some geodesic }g\bigr\}\]</p><p>the set of mid points between <span>$x_1$</span> and <span>$x_3$</span>. Then the function reads</p><p class="math-container">\[d_2^p(x_1,x_2,x_3) = \min_{c ‚àà \mathcal C} d_{\mathcal M}(c,x_2),\]</p><p>see [<a href="../references/#BacakBergmannSteidlWeinmann:2016">BBSW16</a>] for a derivation. In long function names, this might be shortened to <code>TV2</code>.</p><p><strong>See also</strong></p><p><a href="#ManoptExamples.grad_second_order_Total_Variation"><code>grad_second_order_Total_Variation</code></a>, <a href="#ManoptExamples.prox_second_order_Total_Variation"><code>prox_second_order_Total_Variation</code></a>, <a href="#ManoptExamples.Total_Variation"><code>Total_Variation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L140-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.subgrad_Total_Variation" href="#ManoptExamples.subgrad_Total_Variation"><code>ManoptExamples.subgrad_Total_Variation</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = subgrad_TV(M, Œª, p[, k=1; atol=0])
subgrad_TV!(M, X, Œª, p[, k=1; atol=0])</code></pre><p>Compute the (randomized) subgradient <span>$\partial F$</span> of all forward differences occurring, in the power manifold array, i.e. of the function</p><p class="math-container">\[F(p) = \sum_{i}\sum_{j ‚àà \mathcal I_i} d^k(p_i,p_j)\]</p><p>where <span>$i$</span> runs over all indices of the <code>PowerManifold</code> manifold <code>M</code> and <span>$\mathcal I_i$</span> denotes the forward neighbors of <span>$i$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> ‚Äì a <code>PowerManifold</code> manifold</li><li><code>p</code> ‚Äì a point.</li></ul><p><strong>Ouput</strong></p><ul><li>X ‚Äì resulting tangent vector in <span>$T_p\mathcal M$</span>. The computation can also be done in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L477-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManoptExamples.subgrad_Total_Variation-Union{Tuple{T}, Tuple{ManifoldsBase.AbstractManifold, Tuple{T, T}}, Tuple{ManifoldsBase.AbstractManifold, Tuple{T, T}, Int64}} where T" href="#ManoptExamples.subgrad_Total_Variation-Union{Tuple{T}, Tuple{ManifoldsBase.AbstractManifold, Tuple{T, T}}, Tuple{ManifoldsBase.AbstractManifold, Tuple{T, T}, Int64}} where T"><code>ManoptExamples.subgrad_Total_Variation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = subgrad_TV(M, (p,q)[, k=1; atol=0])
subgrad_TV!(M, X, (p,q)[, k=1; atol=0])</code></pre><p>compute the (randomized) subgradient of <span>$\frac{1}{k}d^k_{\mathcal M}(p,q)$</span> with respect to both <span>$p$</span> and <span>$q$</span> (in place of <code>X</code> and <code>Y</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManoptExamples.jl/blob/86f4d5ef315331476c31040acfed8582405cfc68/src/objectives/TotalVariation.jl#L409-L415">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[BBSW16]</dt><dd><div>M.¬†Baƒç√°k, R.¬†Bergmann, G.¬†Steidl and A.¬†Weinmann. <em>A second order non-smooth variational model for restoring manifold-valued images</em>. <a href="https://doi.org/10.1137/15M101988X">SIAM¬†Journal¬†on¬†Scientific¬†Computing <strong>38</strong>, A567‚ÄìA597</a> (2016), <a href="https://arxiv.org/abs/1506.02409">arXiv:1506.02409</a>.</div></dd><dt>[BFPS18]</dt><dd><div>R.¬†Bergmann, J.¬†H.¬†Fitschen, J.¬†Persch and G.¬†Steidl. <em>Priors with coupled first and second order differences for manifold-valued image processing</em>. <a href="https://doi.org/10.1007/s10851-018-0840-y">Journal¬†of¬†Mathematical¬†Imaging¬†and¬†Vision <strong>60</strong>, 1459‚Äì1481</a> (2018), <a href="https://arxiv.org/abs/1709.01343">arXiv:1709.01343</a>.</div></dd><dt>[BFPS17]</dt><dd><div>R.¬†Bergmann, J.¬†H.¬†Fitschen, J.¬†Persch and G.¬†Steidl. <a href="https://doi.org/10.1007/978-3-319-58771-4_36"><em>Infimal convolution coupling of first and second order differences on manifold-valued images</em></a>. In: <em>Scale Space and Variational Methods in Computer Vision: 6th International Conference, SSVM 2017, Kolding, Denmark, June 4‚Äì8, 2017, Proceedings</em>, edited by F.¬†Lauze, Y.¬†Dong and A.¬†B.¬†Dahl (Springer International Publishing, 2017); pp.¬†447‚Äì459.</div></dd><dt>[BG18]</dt><dd><div>R.¬†Bergmann and P.-Y.¬†Gousenbourger. <em>A variational model for data fitting on manifolds by minimizing the acceleration of a B√©zier curve</em>. <a href="https://doi.org/10.3389/fams.2018.00059">Frontiers¬†in¬†Applied¬†Mathematics¬†and¬†Statistics <strong>4</strong></a> (2018), <a href="https://arxiv.org/abs/1807.10090">arXiv:1807.10090</a>.</div></dd><dt>[Bou23]</dt><dd><div>N.¬†Boumal. <a href="https://www.nicolasboumal.net/#book"><em>An Introduction to Optimization on Smooth Manifolds</em></a>. First¬†Edition (<a href="https://doi.org/10.1017/9781009166164">Cambridge University Press, 2023</a>).</div></dd><dt>[Cas59]</dt><dd><div>P.¬†de¬†Casteljau. <em>Outillage methodes calcul</em> (Enveloppe Soleau 40.040, Institute National de la Propri√©t√© Industrielle, Paris., 1959).</div></dd><dt>[Cas63]</dt><dd><div>P.¬†de¬†Casteljau. <em>Courbes et surfaces √† p√¥les</em> (Microfiche P 4147-1, Institute National de la Propri√©t√© Industrielle, Paris., 1963).</div></dd><dt>[DMSC16]</dt><dd><div>J.¬†Duran, M.¬†Moeller, C.¬†Sbert and D.¬†Cremers. <em>Collaborative Total Variation: A General Framework for Vectorial TV Models</em>. <a href="https://doi.org/10.1137/15M102873X">SIAM¬†Journal¬†on¬†Imaging¬†Sciences <strong>9</strong>, 116‚Äì151</a> (2016), <a href="https://arxiv.org/abs/1508.01308">arXiv:1508.01308</a>.</div></dd><dt>[PN07]</dt><dd><div>T.¬†Popiel and L.¬†Noakes. <em>B√©zier curves and <span>$C^2$</span> interpolation in Riemannian manifolds</em>. <a href="https://doi.org/10.1016/j.jat.2007.03.002">Journal¬†of¬†Approximation¬†Theory <strong>148</strong>, 111‚Äì127</a> (2007).</div></dd><dt>[WDS14]</dt><dd><div>A.¬†Weinmann, L.¬†Demaret and M.¬†Storath. <em>Total variation regularization for manifold-valued data</em>. <a href="https://doi.org/10.1137/130951075">SIAM¬†Journal¬†on¬†Imaging¬†Sciences <strong>7</strong>, 2226‚Äì2257</a> (2014).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/Total-Variation/">¬´ Total Variation</a><a class="docs-footer-nextpage" href="../data/">Data ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 11 February 2025 16:09">Tuesday 11 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
