---
title: "Geodesic on Sphere with Obstacle Avoidance"
author: "Laura Weigl, Ronny Bergmann, and Anton Schiela"
date: 2025-11-25
---

```{julia}
#| echo: false
#| output: false
using Pkg;
Pkg.activate("."); # for reproducibility use the local tutorial environment.
```

```{julia}
using LinearAlgebra, SparseArrays, OffsetArrays
using Manifolds, Manopt, ManoptExamples
using GLMakie, Makie, GeometryTypes, Colors, ColorSchemes, NamedColors
using CSV, DataFrames
```

# Introduction

In this example we compute a geodesic on the sphere avoiding an obstacle by applying Newton's method on vector bundles which was introduced in ``[WeiglBergmannSchiela:2025](@cite)``{=commonmark}. This example reproduces the results from the example in Section 6.2 therein.

We consider the sphere $$\mathbb{S}^2$$ equipped with the Riemannian metric $\langle \cdot, \cdot \rangle$ given by the Euclidean inner product with corresponding norm $\lVert\cdot\rVert$ and a time interval $Ω =[0,T]$.

Let $\mathcal X = H^1(Ω, \mathbb S^2)$ and  $\mathcal E^* = T^*\mathcal X$ its cotangent bundle.

Consider the minimization problem

$\min_{γ ∈ H^1(Ω, \mathbb S^2)} \; \frac12 \int_0^T \lVert\dot γ(t)\rVert^2 \; \mathrm{d}t$

under the constraint that $γ_3(t) ≤ 1-h_{\mathrm{ref}} \; \text{ for all } t∈ [0,T]$ where $γ_3(t)$ denotes the third component of $γ(t)∈ \mathbb{S}^2$ and $h_{\mathrm{ref}} ∈ (0,1)$ is a given height. Additionally, we have to take into account that boundary conditions $γ(0) = γ_0$ and $γ(T) = γ_T$ for given $γ_0, γ_T ∈ \mathbb S^2$ are satisfied.

Using a penalty method, also known as Moreau-Yosida regularization with a quadratic penalty term we can rewrite this as an unconstrained minimization problem with a penalty coefficient $p∈ \mathbb R$:

$\min_{γ ∈ H^1(Ω, \mathbb S^2)} \; \underbrace{\frac12 \int_0^T \lVert\dot γ(t)\rVert^2 + p \max(0, γ_3(t) - 1 + h_{\mathrm{ref}})^2 \; \mathrm{d}t}_{=: f(γ)}$

Let $m: \mathbb R → \mathbb R, \, m(x): eqq \max(0, x)$.
The objective is differentiable function $f : \mathcal X → \mathbb R$ with derivative

```math
f'(γ)δ γ = \int_0^T \langle \dotγ(t), \dot{δ γ}(t)\rangle + p \cdot m(γ_3(t) - 1 + h_{\mathrm{ref}})δ γ_3(t)
```

for $δ γ ∈ T_γ \mathcal X$.
This mapping is semismooth and our goal is to find a critical point of $f$ by applying Newton's method on $f'$.

This then yields a geodesic avoiding the north pol cap and connecting $γ_0$ and $γ_T$.

For our example we set

```{julia}
N=200

S = Manifolds.Sphere(2)
power = PowerManifold(S, NestedPowerRepresentation(), N) # power manifold of S

mutable struct variational_space
	manifold::AbstractManifold
	degree::Integer
end

test_space = variational_space(S, 1)

start_interval = -pi/2 + 0.1
end_interval = pi/2 - 0.1
discrete_time = range(; start=start_interval, stop = end_interval, length=N+2) # equidistant discrete time points

θ = pi/4
y0 = [sin(θ)*cos(start_interval),sin(θ)*sin(start_interval),cos(θ)] # startpoint of geodesic
yT = [sin(θ)*cos(end_interval),sin(θ)*sin(end_interval),cos(θ)] # endpoint of geodesic

h_ref = 0.17
```

In order to apply Newton's method to find a zero of $f'$, we need the linear mapping $Q_{f'(γ)}^*\circ f''(γ)$ (cf. \ref{paper}). Since the sphere is an embedded submanifold of $\mathbb R^3$, we can use the formula

$Q_{f'(γ)}^*\circ f''(γ)δ γ\,\phi = f'(γ)(\overset{→}{V}_γ'(γ)δ γ\,\phi) + f''_{\mathbb R^3}(γ)δ γ\,\phi$

for $δ γ, \, \phi ∈ T_γ \mathcal X$, where $\overset{→}{V}_γ(\hat γ) ∈ L(T_γ \mathcal X, T_{\hat{γ}}\mathcal X)$ is a vector transport and

$f_{\mathbb R^3}''(γ)δ γ\, \phi = \int_0^T \langle \dot{δ γ}(t), \dot{\phi}(t)\rangle + p \cdot m'(γ_3(t) - 1 + h_{\mathrm{ref}})\phi_{3}(t) δ γ_{3}(t)$

is an (euclidean) Newton-derivative of f'.

We define a structure that has to be filled for two purposes:
* Definition of an integrand and its derivative
* Definition of a vector transport and its derivative

```{julia}
mutable struct DifferentiableMapping{F1<:Function,F2<:Function,T}
	value::F1
	derivative::F2
	scaling_penalty::T
end;
```

The following routines define a vector transport and its euclidean derivative. As seen above, they are needed to derive $Q_{f'(γ)}^*\circ f''(γ)$.

As a vector transport we use the (pointwise) orthogonal projection onto the tangent spaces, i.e. for $p, q ∈ \mathbb S^2$ and $X ∈ T_p\mathbb S^2$ we set

$\overset{→}{V}_{p}(q)X = (I-q\cdot q^T)X ∈ T_q\mathbb S^2.$

The derivative of the vector transport is then given by

$\left(\frac{d}{dq}\overset{→}{V}_{p}(q)\big\vert_{q=p}δ q\right)X = \left( - δ q\cdot p^T - p\cdot δ q^T\right)\cdot X.$

```{julia}
function transport_by_proj(S, p, X, q)
	return X - q*(q'*X)
end
function transport_by_proj_prime(S, p, X, dq)
	return (- dq*p' - p*dq')*X
end
transport = DifferentiableMapping(transport_by_proj,transport_by_proj_prime,nothing)
```

The following two routines define the integrand of $f'$ and the euclidean second derivative $f''_{\mathbb R^3}$. Here, a Newton-derivative of the maximum function given by

```math
m'(x): eqq \begin{cases}
        0 &: \; x<0 \\
        \text{arbitrary} &: \; x= 0\\
        1 &: \; x>0
    \end{cases}
```

is used. A scaling parameter for the penalty parameter is also employed.

```{julia}
function f_prime_at(Integrand, y, ydot, B, Bdot)
  	return ydot'*Bdot + Integrand.scaling_penalty * max(0.0, y[3] - 1.0 + h_ref)*B[3]
end
function max_prime(y)
	if y[3] < 1.0 - h_ref
		return 0.0
	else
		return 1.0
	end
end
function f_second_at(Integrand,y,ydot,B1,B1dot,B2,B2dot)
	return B1dot'*B2dot + Integrand.scaling_penalty*max_prime(y)*B1[3]*B2[3]
end
integrand = DifferentiableMapping(f_prime_at,f_second_at,1.0)
```

##  Newton Equation

In this example we implement a functor to compute the Newton matrix and the right hand side for the Newton equation \ref{paper}

```math
Q^*_{f''(γ)}\circ f''(γ)δ γ + f'(γ) = 0^*_γ
```

by using the assembler provided in ManoptExamples.jl (cf. Referenz).

It returns the matrix and the right hand side in base representation.

The assembly routines need a function for evaluation the iterates at the left and right quadrature point.

```{julia}
evaluate(p, i, tloc) = (1.0-tloc)*p[i-1]+tloc*p[i];

struct NewtonEquation{F, TS, T, I, NM, Nrhs}
	integrand::F
	test_space::TS
	transport::T
	time_interval::I
	A::NM
	b::Nrhs
end

function NewtonEquation(M, F, test_space, VT, interval)
	n = manifold_dimension(M)
	A = spzeros(n,n)
	b = zeros(n)
	return NewtonEquation{typeof(F), typeof(test_space), typeof(VT), typeof(interval), typeof(A), typeof(b)}(F, test_space, VT, interval, A, b)
end

function (ne::NewtonEquation)(M, VB, p)
	n = manifold_dimension(M)
	ne.A .= spzeros(n,n)
	ne.b .= zeros(n)

	Op = OffsetArray([y0, p..., yT], 0:(length(p)+1))

	ManoptExamples.get_jacobian!(M, Op, evaluate, ne.A, ne.integrand, ne.transport, ne.time_interval; test_space=ne.test_space)

	ManoptExamples.get_right_hand_side!(M, Op, evaluate, ne.b, ne.integrand, ne.time_interval; test_space=ne.test_space)
end
```

We compute the Newton direction $δ γ$ by solving the linear system given by the base representation of the Newton equation directly and return the Newton direction in vector representation:

```{julia}
function solve_in_basis_repr(problem, newtonstate)
	X_base = (problem.newton_equation.A) \ (-problem.newton_equation.b)
	return get_vector(problem.manifold, newtonstate.p, X_base, DefaultOrthogonalBasis())
end;
```

For the computation of a solution of the penalized problem we use a simple path-following method increasing the penalty parameter by a factor 1.2 in each iteration. For the first iteration we use a curve along the latitude connecting $γ_0$ and $γ_T$:

```{julia}
y(t) = [sin(θ)*cos(t), sin(θ)*sin(t), cos(θ)]
discretized_y = [y(ti) for ti in discrete_time[2:end-1]];
```

```{julia}
y_star = copy(power, discretized_y)

	integrand.scaling_penalty = 5.0

	NE = NewtonEquation(power, integrand, test_space, transport, discrete_time)

	st_res = vectorbundle_newton(power, TangentBundle(power), NE, y_star; sub_problem=solve_in_basis_repr,
	stopping_criterion=(StopAfterIteration(150)|StopWhenChangeLess(power,1e-13; outer_norm=Inf)),
	retraction_method=ProjectionRetraction(),
	debug=[:Iteration, (:Change, "Change: %1.8e"), "\n", :Stop, (:Stepsize, "Stepsize: %1.8e"), "\n",],
	return_state=true)

	y_star = copy(power, get_solver_result(st_res))

	for i in range(1,50)
		integrand.scaling_penalty *= 1.2

		NE = NewtonEquation(power, integrand, test_space, transport, discrete_time)

		st_res = vectorbundle_newton(power, TangentBundle(power), NE, y_star; sub_problem=solve_in_basis_repr,
		stopping_criterion=(StopAfterIteration(150)|StopWhenChangeLess(power,1e-13; outer_norm=Inf)),
		retraction_method=ProjectionRetraction(),
		debug=[:Iteration, (:Change, "Change: %1.8e"), "\n", :Stop],
		return_state=true
		)
		y_star = copy(power, get_solver_result(st_res));
	end
```

This yields the geodesic shown below avoiding the north pole cap and connecting two points $γ_0$ and $γ_T$ (orange). The curve along the latitude connecting the two points (used as initial curve for the first iteration) is plotted as well (blue).

```{julia}
n = 45
u = range(0,stop=2*π,length=n);
v = range(0,stop=π,length=n);
sx = zeros(n,n); sy = zeros(n,n); sz = zeros(n,n)

for i in 1:n
    for j in 1:n
        sx[i,j] = cos.(u[i]) * sin(v[j]);
        sy[i,j] = sin.(u[i]) * sin(v[j]);
        sz[i,j] = cos(v[j]);
    end
end

x = acos(1-h_ref)

circx = zeros(n)
circy = zeros(n)
circz = zeros(n)
for i in 1:n
	circx[i] = cos.(u[i]) * sin(x);
	circy[i] = sin.(u[i]) * sin(x);
	circz[i] = cos(x);
end

fig, ax, plt = meshscatter(
  sx,sy,sz,
  color = fill(RGBA(1.,1.,1.,0.), n, n),
  shading = Makie.automatic,
  transparency=true
)

geodesic_start = [y0, discretized_y ...,yT]

ax.show_axis = false
wireframe!(ax, sx, sy, sz, color = RGBA(0.5,0.5,0.7,0.1); transparency=true)
π1(x) = 1.0*x[1]
π2(x) = 1.0*x[2]
π3(x) = 1.0*x[3]

scatterlines!(ax, circx, circy, circz; markersize =2, color=:black, linewidth=2)

scatterlines!(ax, π1.(y_star), π2.(y_star), π3.(y_star); markersize =8, color=:orange, linewidth=2)

scatterlines!(ax, π1.(geodesic_start), π2.(geodesic_start), π3.(geodesic_start); markersize =8, color=:blue, linewidth=2)

scatter!(ax, π1.([y0]), π2.([y0]), π3.([y0]); markersize = 10, color=:green)
scatter!(ax, π1.([yT]), π2.([yT]), π3.([yT]); markersize = 10, color=:red)

fig
```


## Technical details

This tutorial is cached. It was last run on the following package versions.

```{julia}
#| code-fold: true
using Pkg
Pkg.status()
```
```{julia}
#| code-fold: true
using Dates
now()
```

## Literature

````{=commonmark}
```@bibliography
Pages = ["Elastic-Geodesic-Obstacle.md"]
Canonical=false
```
````