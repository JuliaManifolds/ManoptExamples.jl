{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"A comparison of the NCRPG with the CPPA on the Grassmann manifold\"\n",
        "author: \"Hajg Jasa\"\n",
        "date: 05/09/2025\n",
        "# engine: julia\n",
        "---\n",
        "\n",
        "\n",
        "## Introduction\n",
        "\n",
        "In this example we compare the Nonconvex Riemannian Proximal Gradient (NCRPG) method [BergmannJasaJohnPfeffer:2025:1](@cite) with the Cyclic Proximal Point Algorithm, which was introduced in [Bacak:2014](@cite), on the space of symmetric positive definite matrices and on hyperbolic space.\n",
        "This example reproduces the results from [BergmannJasaJohnPfeffer:2025:1](@cite), Section 5.4.\n"
      ],
      "id": "a38378b0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: true\n",
        "#| output: false\n",
        "using Pkg;\n",
        "cd(@__DIR__)\n",
        "Pkg.activate(\".\"); # for reproducibility use the local tutorial environment.\n",
        "\n",
        "Pkg.develop(path=\"../\") # a trick to work on the local dev version\n",
        "\n",
        "export_orig = true\n",
        "export_table = true\n",
        "export_result = true\n",
        "benchmarking = true\n",
        "\n",
        "experiment_name = \"\"\n",
        "results_folder = joinpath(@__DIR__, experiment_name)\n",
        "!isdir(results_folder) && mkdir(results_folder)"
      ],
      "id": "66c9a245",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "using PrettyTables\n",
        "using BenchmarkTools\n",
        "using CSV, DataFrames\n",
        "using ColorSchemes, Plots\n",
        "using Random, LinearAlgebra, LRUCache\n",
        "using ManifoldDiff, Manifolds, Manopt, ManoptExamples"
      ],
      "id": "8b6e4bf4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## The Problem\n",
        "\n",
        "Let $\\mathcal M$ be a Riemannian manifold and $\\{q_1,\\ldots,q_N\\} \\in \\mathcal M$ denote $N = 1000$\n",
        "Gaussian random data points.\n",
        "Let $g \\colon \\mathcal M \\to \\mathbb R$ be defined by\n",
        "\n",
        "```math\n",
        "g(p) = \\sum_{j = 1}^N w_j \\, \\mathrm{dist}(p, q_j)^2,\n",
        "```\n",
        "\n",
        "where $w_j$, $j = 1, \\ldots, N$ are positive weights such that $\\sum_{j = 1}^N w_j = 1$.\n",
        "In our experiments, we choose the weights $w_j = \\frac{1}{2N}$.\n",
        "Observe that the function $g$ is strongly convex with respect to the Riemannian metric on $\\mathcal M$.\n",
        "The Riemannian geometric median $p^*$ of the dataset $\\{q_1,\\ldots,q_N\\}$\n",
        "\n",
        "```math\n",
        "\\mathcal D = \\{\n",
        "    q_1,\\ldots,q_N \\, \\vert \\, q_j \\in \\mathcal M\\text{ for all } j = 1,\\ldots,N\n",
        "\\}\n",
        "```\n",
        "\n",
        "is then defined as\n",
        "\n",
        "```math\n",
        "    p^* \\coloneqq \\operatorname*{arg\\,min}_{p \\in \\mathcal M} g(p),\n",
        "```\n",
        "\n",
        "where equality is justified since $p^*$ is uniquely determined on Hadamard manifolds. \n",
        "\n",
        "Let now $\\bar q \\in \\cM$ be a given point, and let $h \\colon \\mathcal M \\to \\mathbb R$ be defined by\n",
        "\n",
        "```math\n",
        "h(p) = \\alpha \\mathrm{dist}(p, \\bar q).\n",
        "``` \n",
        "\n",
        "We define our total objective function as $f = g + h$.\n",
        "Notice that this objective function is strongly convex with respect to the Riemannian metric on $\\mathcal M$ thanks to $g$.\n",
        "The goal is to find the minimizer of $f$ on $\\mathcal M$, which heuristically is an interpolation between the geometric median $p^*$ and $\\bar q$.\n",
        "\n",
        "\n",
        "## Numerical Experiment\n",
        "\n",
        "We initialize the experiment parameters, as well as some utility functions."
      ],
      "id": "af40bd8c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "random_seed = 100\n",
        "experiment_name = \"NCRPG-Grassmann\"\n",
        "results_folder = joinpath(@__DIR__, experiment_name)\n",
        "!isdir(results_folder) && mkdir(results_folder)\n",
        "\n",
        "atol = 1e-8\n",
        "max_iters = 5000\n",
        "N = 1000 # number of data points\n",
        "α = 3/2 # weight for the median component (h)\n",
        "gr_dims = [(5, 2), (10, 4), (50, 10), (100, 20), (200, 40)] # dimensions of the Grassmann manifold"
      ],
      "id": "b1ac4b21",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "# Objective, gradient, and proxes\n",
        "g(M, p, data) = 1/2length(data) * sum(distance.(Ref(M), data, Ref(p)).^2)\n",
        "grad_g(M, p, data) = 1/length(data) * sum(ManifoldDiff.grad_distance.(Ref(M), data, Ref(p), 2))\n",
        "# \n",
        "h(M, p, q) = α * distance(M, p, q)\n",
        "prox_h(M, λ, p, q) = ManifoldDiff.prox_distance(M, α * λ, q, p, 1)\n",
        "# \n",
        "f(M, p, data, q) = g(M, p, data) + h(M, p, q)\n",
        "# CPPA needs the proximal operators for the total objective\n",
        "function proxes_f(data, q)\n",
        "    proxes = Function[(M, λ, p) -> ManifoldDiff.prox_distance(M, λ / length(data), di, p, 2) for di in data]\n",
        "    push!(proxes, (M, λ, p) -> ManifoldDiff.prox_distance(M, α * λ, q, p, 1))\n",
        "    return proxes\n",
        "end\n",
        "# Function to generate points close to the given point p\n",
        "function close_point(M, p, tol; retraction_method=Manifolds.default_retraction_method(M, typeof(p)))\n",
        "    X = rand(M; vector_at = p)\n",
        "    X .= tol * rand() * X / norm(M, p, X)\n",
        "    return retract(M, p, X, retraction_method)\n",
        "end\n",
        "# Estimate Lipschitz constant of the gradient of g\n",
        "function estimate_lipschitz_constant(M, g, grad_g, anchor, R, N=1000)\n",
        "    constants = []\n",
        "    for i in 1:N\n",
        "        p = close_point(M, anchor, R)\n",
        "        q = close_point(M, anchor, R)\n",
        "\n",
        "        push!(constants, 2/distance(M, q, p)^2 * (g(M, q) - g(M, p) - inner(M, p, grad_g(M, p), log(M, p, q))))\n",
        "    end\n",
        "    return maximum(constants)\n",
        "end"
      ],
      "id": "b17362f6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We introduce some keyword arguments for the solvers we will use in this experiment"
      ],
      "id": "04d5999e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "pgm_kwargs(initial_stepsize) = [\n",
        "    :record => [:Iteration, :Cost, :Iterate],\n",
        "    :return_state => true,\n",
        "    :stepsize => ProxGradBacktracking(; strategy=:nonconvex, initial_stepsize=initial_stepsize),\n",
        "    :stopping_criterion => StopWhenAny(\n",
        "        StopWhenGradientMappingNormLess(atol), StopAfterIteration(max_iters)\n",
        "    ),\n",
        "]\n",
        "pgm_bm_kwargs(initial_stepsize) = [\n",
        "    :record => [:Iteration, :Cost, :Iterate],\n",
        "    :return_state => true,\n",
        "    :stepsize => ProxGradBacktracking(; strategy=:nonconvex,   \n",
        "        initial_stepsize=initial_stepsize),\n",
        "    :stopping_criterion => StopWhenAny(\n",
        "        StopWhenGradientMappingNormLess(atol), StopAfterIteration(max_iters)\n",
        "    ), \n",
        "]\n",
        "\n",
        "cppa_kwargs(M) = [\n",
        "    :record => [:Iteration, :Cost, :Iterate],\n",
        "    :return_state => true,\n",
        "    :stopping_criterion => StopWhenAny(\n",
        "        StopAfterIteration(max_iters), StopWhenChangeLess(M, atol)\n",
        "    ),\n",
        "]\n",
        "cppa_bm_kwargs(M) = [\n",
        "    :record => [:Iteration, :Cost, :Iterate],\n",
        "    :return_state => true,\n",
        "    :stopping_criterion => StopWhenAny(\n",
        "        StopAfterIteration(max_iters), StopWhenChangeLess(M, atol)\n",
        "    ),\n",
        "]"
      ],
      "id": "8334d1a5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Before running the experiments, we initialize data collection functions that we will use later"
      ],
      "id": "7b008606"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "global col_names_1 = [\n",
        "    :Dimension,\n",
        "    :Iterations_1,\n",
        "    :Time_1,\n",
        "    :Objective_1,\n",
        "    :Iterations_2,\n",
        "    :Time_2,\n",
        "    :Objective_2,\n",
        "]\n",
        "col_types_1 = [\n",
        "    Int64,\n",
        "    Int64,\n",
        "    Float64,\n",
        "    Float64,\n",
        "    Float64,\n",
        "    Float64,\n",
        "    Float64,\n",
        "]\n",
        "named_tuple_1 = (; zip(col_names_1, type[] for type in col_types_1 )...)\n",
        "global col_names_2 = [\n",
        "    :Dimension,\n",
        "    :Iterations,\n",
        "    :Time,\n",
        "    :Objective,\n",
        "]\n",
        "col_types_2 = [\n",
        "    Int64,\n",
        "    Int64,\n",
        "    Float64,\n",
        "    Float64,\n",
        "]\n",
        "named_tuple_2 = (; zip(col_names_2, type[] for type in col_types_2 )...)\n",
        "function initialize_dataframes(results_folder, experiment_name, subexperiment_name, named_tuple_1, named_tuple_2)\n",
        "    A1 = DataFrame(named_tuple_1)\n",
        "    CSV.write(\n",
        "        joinpath(\n",
        "            results_folder,\n",
        "            experiment_name * \n",
        "            # \"_$subexperiment_name\" * \n",
        "            \"-Comparisons.csv\",\n",
        "        ),\n",
        "        A1;\n",
        "        header=false,\n",
        "    )\n",
        "    # A2 = DataFrame(named_tuple_2)\n",
        "    # CSV.write(\n",
        "    #     joinpath(\n",
        "    #         results_folder,\n",
        "    #         experiment_name * \"_$subexperiment_name\" * \"-Comparisons-Subgrad.csv\",\n",
        "    #     ),\n",
        "    #     A2;\n",
        "    #     header=false,\n",
        "    # )\n",
        "    return A1#, A2\n",
        "end"
      ],
      "id": "0256cccf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "function export_dataframes(M, records, times, results_folder, experiment_name, subexperiment_name, col_names_1, col_names_2)\n",
        "    B1 = DataFrame(;\n",
        "        Dimension=manifold_dimension(M),\n",
        "        Iterations_1=maximum(first.(records[1])),\n",
        "        Time_1=times[1],\n",
        "        Objective_1=minimum([r[2] for r in records[1]]),\n",
        "        Iterations_2=maximum(first.(records[2])),\n",
        "        Time_2=times[2],\n",
        "        Objective_2=minimum([r[2] for r in records[2]]),\n",
        "    )\n",
        "    # B2 = DataFrame(;\n",
        "    #     Dimension=manifold_dimension(M),\n",
        "    #     Iterations=median(last.(records[3])),\n",
        "    #     Time=times[3],\n",
        "    #     Objective=minimum([r[2] for r in records[3]]),\n",
        "    # )\n",
        "    return B1#, B2\n",
        "end\n",
        "function write_dataframes(\n",
        "    B1, \n",
        "    # B2, \n",
        "    results_folder, \n",
        "    experiment_name, \n",
        "    subexperiment_name\n",
        ")\n",
        "    CSV.write(\n",
        "        joinpath(\n",
        "            results_folder,\n",
        "            experiment_name *\n",
        "            # \"_$subexperiment_name\" *\n",
        "            \"-Comparisons.csv\",\n",
        "            # -Convex-Prox.csv\",\n",
        "        ),\n",
        "        B1;\n",
        "        append=true,\n",
        "    )\n",
        "    # CSV.write(\n",
        "    #     joinpath(\n",
        "    #         results_folder,\n",
        "    #         experiment_name *\n",
        "    #         \"_$subexperiment_name\" *\n",
        "    #         \"-Comparisons-Subgrad.csv\",\n",
        "    #     ),\n",
        "    #     B2;\n",
        "    #     append=true,\n",
        "    # )\n",
        "end"
      ],
      "id": "7d0e614d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "subexperiment_name = \"Gr\"\n",
        "k_max_gr = 2.0\n",
        "global A1_Gr = initialize_dataframes(\n",
        "    results_folder,\n",
        "    experiment_name,\n",
        "    subexperiment_name,\n",
        "    named_tuple_1,\n",
        "    named_tuple_2\n",
        ")\n",
        "\n",
        "for (n, m) in gr_dims\n",
        "\n",
        "    Random.seed!(random_seed)\n",
        "\n",
        "    M = Grassmann(Int(n), Int(m))\n",
        "    data = [rand(M) for _ in 1:N]\n",
        "    q = rand(M) # we can artificially craft a point for the median component, i.e. h\n",
        "    p0 = rand(M) #data[minimum(Tuple(findmax(dists)[2]))]\n",
        "\n",
        "    g_gr(M, p) = g(M, p, data)\n",
        "    # h_gr(M, p) = h(M, p, q)\n",
        "    grad_g_gr(M, p) = grad_g(M, p, data)\n",
        "    proxes_f_gr = proxes_f(data, q)\n",
        "    prox_h_gr(M, λ, p) = prox_h(M, λ, p, q)\n",
        "    f_gr(M, p) = f(M, p, data, q)\n",
        "\n",
        "    # D = 5/2 * maximum([distance(M, p0, di) for di in vcat(data, [q])])\n",
        "    # L_g = 2 * estimate_lipschitz_constant(M, g_gr, grad_g_gr, p0, D)\n",
        "    initial_stepsize = 1.0 #3/(2 * L_g)\n",
        "\n",
        "    # Optimization\n",
        "    pgm = proximal_gradient_method(M, f_gr, g_gr, grad_g_gr, prox_h_gr, p0; pgm_kwargs(initial_stepsize)...)\n",
        "    pgm_result = get_solver_result(pgm)\n",
        "    pgm_record = get_record(pgm)\n",
        "\n",
        "    cppa = cyclic_proximal_point(M, f_gr, proxes_f_gr, p0; cppa_kwargs(M)...)\n",
        "    cppa_result = get_solver_result(cppa)\n",
        "    cppa_record = get_record(cppa)\n",
        "\n",
        "    records = [\n",
        "        pgm_record,\n",
        "        cppa_record,\n",
        "    ]\n",
        "\n",
        "    if benchmarking\n",
        "        pgm_bm = @benchmark proximal_gradient_method($M, $f_gr, $g_gr, $grad_g_gr, $prox_h_gr, $p0; $pgm_bm_kwargs($initial_stepsize)...)\n",
        "        cppa_bm = @benchmark cyclic_proximal_point($M, $f_gr, $proxes_f_gr, $p0; cppa_bm_kwargs($M)...)\n",
        "        \n",
        "        times = [\n",
        "            median(pgm_bm).time * 1e-9,\n",
        "            median(cppa_bm).time * 1e-9,\n",
        "        ]\n",
        "\n",
        "        B1 = export_dataframes(\n",
        "            M,\n",
        "            records,\n",
        "            times,\n",
        "            results_folder,\n",
        "            experiment_name,\n",
        "            subexperiment_name,\n",
        "            col_names_1,\n",
        "            col_names_2,\n",
        "        )\n",
        "\n",
        "        append!(A1_Gr, B1)\n",
        "        # append!(A2_Gr, B2)\n",
        "        (export_table) && (write_dataframes(B1, results_folder, experiment_name, subexperiment_name))\n",
        "    end\n",
        "end"
      ],
      "id": "a275a3f8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can take a look at how the algorithms compare to each other in their performance with the following table, where columns 2 to 4 relate to the CRPG, while columns 5 to 7 refer to the CPPA..."
      ],
      "id": "0c6b9e6e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: true\n",
        "benchmarking && pretty_table(A1_Gr, tf = tf_markdown, header=col_names_1)"
      ],
      "id": "ca7f75f0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Technical details\n",
        "\n",
        "This tutorial is cached. It was last run on the following package versions.\n"
      ],
      "id": "fc44b78d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "using Pkg\n",
        "Pkg.status()"
      ],
      "id": "417d4724",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| echo: false\n",
        "#| output: asis\n",
        "using Dates\n",
        "println(\"This tutorial was last rendered $(Dates.format(now(), \"U d, Y, H:M:S\")).\");"
      ],
      "id": "95419f9e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Literature\n",
        "\n",
        "\n",
        "````{=commonmark}\n",
        "```@bibliography\n",
        "Pages = [\"NCRPG-Grassmann.md\"]\n",
        "Canonical=false\n",
        "```\n",
        "````"
      ],
      "id": "5b0b7fbf"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.5",
      "path": "/Users/hajgj/Library/Jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}