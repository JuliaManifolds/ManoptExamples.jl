---
title: "A 2D illustration of different norms in the Procrustes problem"
author: "Ronny Bergmann"
date: 11/10/2025
---

```{julia}
#| echo: false
#| code-fold: true
#| output: false
using Pkg;
cd(@__DIR__)
Pkg.activate(".");
```
```{julia}
using CairoMakie, CSV, DataFrames, LinearAlgebra, Manifolds, Manopt, NamedColors, PrettyTables,  Random
```

```{julia}
#| echo: false
#| code-fold: true
#| output: false
# Parameters for this Notebook,
# where to export results to if these get activated
folder = "duck/"
(!isdir(folder)) && (mkdir(folder))
experiment_name = "abstract-duck-"
# write out CSV files of both point data and results
write_csv = true
# save png files of the plots separately in a folder
write_png = true
# an export helper to store 2D point data
function export_point_data(filename, data; active=write_csv, prefix=folder*experiment_name)
    active && CSV.write(prefix*filename, DataFrame(x=data[1,:], y=data[2,:]))
end
# Colors
paul_tol = load_paul_tol()
color_duck = paul_tol["lightblue"]
color_Frobenius = paul_tol["lightyellow"]
color_spectral = paul_tol["lightorange"]
color_robust = paul_tol["lightmint"]
```

This example reproduces the results preented in Section 5 of ``[JasaBergmannKuemmerleAthreyaLubberts:2025](@cite)``{=commonmark} about the effect of the Procrustes problem

```math
\operatorname*{arg\,min}_{p \in \mathrm{SO}(n)} \lVert A - pB\rVert_s
```

for different norms ``s ∈ \{\mathrm{F},\mathrm{S},\mathrm{R}\}``, namely the Frobenius, spectral and a robust norm, respectively.

We first define a set of points, that originally started with a duch example from [the master thesis of S. Oddsen](https://hdl.handle.net/11250/3189974), hence the name “`duck`”, though for this experiment it is merely an abstract idea of a duck.

```{julia}
#| output: false
duck = [
    # 1 left (a bit moved up), maybe a beak
    # 2 right (a bit moved down), maybe a tail
    # 3 top, maybe its head
    # 4 bottom – feat are under water, so we have an abstract duck!
    -1/2 1/2 1/2 -1/4 0.0 1/4 -3/8 -1/8 1/8 3/8;
    1/4 -2/12 -5/12 1/2 1/2 1/2 -1/2 -1/2 -1/2 -1/2
]
```
```{julia}
#| echo: false
#| code-fold: true
#| output: false
export_point_data("-orig.csv", duck)
```

The general scheme of the following experiments is as follows:
We first rotate the `duck` by a known angle, then apply certain noises and try to recover the true rotation angle.

```{julia}
#| output: false
α_true = 5π/8
R(α) = [cos(α) sin(α); -sin(α) cos(α)]
α(R) = atan(R[2,1], R[1,1])
error_on_nonoutliers(res, remaining_indices) = norm(
    res[:,remaining_indices]-duck[:,remaining_indices]
)
# true exact minimizer if there were not errors
p_true = R(-α_true) # Point on SO(2), the true reconstruction point we aim for
rotated_duck = p_true'*duck
```
```{julia}
#| echo: false
#| code-fold: true
#| output: false
export_point_data("-rotated.csv", rotated_duck)
```

## Manifold, costs, and minimizers

```{julia}
#| output: false
M = Rotations(2)
```

```{julia}
#| output: false
@doc raw"""
    Spectral_cost(M, p)

Compute the spectral norm ``\lVert p\cdot B- A\rVert_2``.
"""
Spectral_cost(M, p; B=r_duck, A=duck) = opnorm(p*B - A)

@doc raw"""
    Frobenius_cost(M, p)

Compute the Frobenious norm ``\lVert p\cdot B- A\rVert_{\mathrm{F}}``.
"""
Frobenius_cost(M, p; B=r_duck, A=duck) = norm(p*B - A)

@doc raw"""
    Robust_cost(M, p)

Compute the 2-1-norm ``\lVert p\cdot B- A\rVert_{2,1}``, i.e. the sum of the 2-norms of the columns.
"""
Robust_cost(M,p; B=r_duck, A=duck) = sum([norm(c, 2.0) for c in eachcol(p*B-A)])
```

```{julia}
p0 = Matrix{Float64}(I,2,2)
```

```{julia}
#| output: false
function Frobenius_minimizer(A,B; p0=p0)
    svd_AB = svd(A*B')
    return svd_AB.U*svd_AB.V'
end
function spectral_minimizer(A,B; p0=p0)
    return mesh_adaptive_direct_search(
        M,
       (M,p) -> Spectral_cost(M, p; A=A, B=B), p0;
       debug=[:Iteration, :Cost, "\n", 10, :Stop]
    )
end
function robust_minimizer(A, B; p0=p0)
    return mesh_adaptive_direct_search(
         M,
        (M,p) -> Robust_cost(M, p; A=A, B=B), p0;
        debug=[:Iteration, :Cost, "\n", 10, :Stop]
    )
 end
```

## Experiment 1: Outliers that are orthogonal and the same distance

We start with two outliers at the same (even) distance

```{julia}
#| output: false
sub_experiment1 = "even"
outlier_shifts1 = [[2.0, 0.0], [0.0,2.0]]
outlier_indices1 = [2,8]
remaining_indices1 = [k for k=1:size(duck,2) if k ∉ outlier_indices1]
```

Since we apply these outliers after rotation, one way to illustrate them on the `duck` is to rotate them back and draw that into the original data.

```{julia}
#| output: false
outlier_shifts1_rp = [R(-α_true)x for x in outlier_shifts1]
outlier_lines1 = [
    [
        [
            duck[xy,outlier_indices1[k]],
            duck[xy,outlier_indices1[k]] + outlier_shifts1_rp[k][xy]
        ] for xy = 1:2
    ]
    for k=1:length(outlier_indices1)
]
```
```{julia}
#| echo: false
#| code-fold: true
#| output: false
for (i,v) in enumerate(outlier_shifts1_rp)
    export_point_data(
        sub_experiment1*"-orig-outlier$(i).csv",
        hcat(duck[:,outlier_indices1[i]], duck[:,outlier_indices1[i]] .+ outlier_shifts1_rp[i])
    )
end
```

```{julia}
outliers1_rotated_duck = copy(rotated_duck)
    # generate outliers on the rotated duck
    for (i,k) in enumerate(outlier_indices1)
        outliers1_rotated_duck[:,k] += outlier_shifts1[i]
    end
```

We compute the minimizers

```{julia}
p1F = Frobenius_minimizer(duck, outliers1_rotated_duck)
p1S = spectral_minimizer(duck, outliers1_rotated_duck)
p1R = robust_minimizer(duck, outliers1_rotated_duck)
nothing
```

and we generate the rotated results

```{julia}
#| output: false
duck1F = p1F * outliers1_rotated_duck
duck1S = p1S * outliers1_rotated_duck
duck1R = p1R * outliers1_rotated_duck
```

The result is

```{julia}
res1_fig = Figure()
res1_ax = Axis(res1_fig[1, 1], title="Reconstructing the duck “$(sub_experiment1)” ")
scatter!(res1_ax, duck[1,:], duck[2,:], label="a duck", color=color_duck, markersize=20)
for k=1:length(outlier_indices1)
    lines!(res1_ax, outlier_lines1[k][1], outlier_lines1[k][2], color=:black)
end
scatter!(res1_ax, duck1F[1,:], duck1F[2,:], label="Frobenius result", color=color_Frobenius, markersize=10)
scatter!(res1_ax, duck1S[1,:], duck1S[2,:], label="Spectral result", color=color_spectral, markersize=10)
scatter!(res1_ax, duck1R[1,:], duck1R[2,:], label="Robust result", color=color_robust, markersize=10)
axislegend(res1_ax,position = :lt)
res1_fig
```

```{julia}
#| echo: false
#| code-fold: true
#| output: false
write_png && save(folder*experiment_name*sub_experiment1*"_results.png",res1_fig)
```

We can also look at the numbers: How well the angle is reconstructed and how large the error on the non-outliers is;

```{julia}
α_errors = [α(p1F), α(p1S), α(p1R)] .- α_true
l2_errors = [error_on_nonoutliers(d, remaining_indices1) for d in [duck1F, duck1S, duck1R]]
pretty_table(
    DataFrame(:rownames => ["angle", "non-outlier"], :F => [α_errors[1], l2_errors[1]], :S => [α_errors[2], l2_errors[2]], :R => [α_errors[3], l2_errors[3]]);
    tf=tf_markdown, header=["error on", "Frobenius", "spectral", "robust"])
```

We see both in outlier error and angle reconstruction, Frobenius is not reconstructions perfectly, while both spectral and robust do.

## Experiment 2: Outliers that are orthogonal and the same distance

We start with two outliers that are orthogonal but of different length in movement.

```{julia}
#| output: false
sub_experiment2 = "orth"
outlier_shifts2 = [[1.0, 0.0], [0.0,2.0]]
outlier_indices2 = [2,8]
remaining_indices2 = [k for k=1:size(duck,2) if k ∉ outlier_indices2]
```

Since we apply these outliers after rotation, one way to illustrate them on the `duck` is to rotate them back and draw that into the original data.

```{julia}
#| output: false
outlier_shifts2_rp = [R(-α_true)x for x in outlier_shifts2]
outlier_lines2 = [
    [
        [
            duck[xy,outlier_indices2[k]],
            duck[xy,outlier_indices2[k]] + outlier_shifts2_rp[k][xy]
        ] for xy = 1:2
    ]
    for k=1:length(outlier_indices2)
]
```
```{julia}
#| echo: false
#| code-fold: true
#| output: false
for (i,v) in enumerate(outlier_shifts2_rp)
    export_point_data(
        sub_experiment2*"-orig-outlier$(i).csv",
        hcat(duck[:,outlier_indices2[i]], duck[:,outlier_indices2[i]] .+ outlier_shifts2_rp[i])
    )
end
```

```{julia}
outliers2_rotated_duck = copy(rotated_duck)
    # generate outliers on the rotated duck
    for (i,k) in enumerate(outlier_indices2)
        outliers2_rotated_duck[:,k] += outlier_shifts2[i]
    end
```

We compute the minimizers

```{julia}
p2F = Frobenius_minimizer(duck, outliers2_rotated_duck)
p2S = spectral_minimizer(duck, outliers2_rotated_duck)
p2R = robust_minimizer(duck, outliers2_rotated_duck)
nothing
```

and we generate the rotated results

```{julia}
#| output: false
duck2F = p2F * outliers2_rotated_duck
duck2S = p2S * outliers2_rotated_duck
duck2R = p2R * outliers2_rotated_duck
```

The result is

```{julia}
    res2_fig = Figure()
    res2_ax = Axis(res2_fig[1, 1], title="Reconstructing the duck “$(sub_experiment2)” ")
    scatter!(res2_ax, duck[1,:], duck[2,:], label="a duck", color=color_duck, markersize=20)
    for k=1:length(outlier_indices2)
        lines!(res2_ax, outlier_lines2[k][1], outlier_lines2[k][2], color=:black)
    end
    scatter!(res2_ax, duck2F[1,:], duck2F[2,:], label="Frobenius result", color=color_Frobenius, markersize=10)
    scatter!(res2_ax, duck2S[1,:], duck2S[2,:], label="Spectral result", color=color_spectral, markersize=10)
    scatter!(res2_ax, duck2R[1,:], duck2R[2,:], label="Robust result", color=color_robust, markersize=10)
    axislegend(res2_ax,position = :lt)
    res2_fig
```

```{julia}
#| echo: false
#| code-fold: true
#| output: false
write_png && save(folder*experiment_name*sub_experiment2*"_results.png",res2_fig)
```

## Experiment 3: Outliers that are orthogonal and the same distance

We continue with two outliers that are neither of same length nor orthogonal.

```{julia}
#| output: false
sub_experiment3 = "orth"
outlier_shifts3 = [[1.0, 2.0], [0.0,2.0]]
outlier_indices3 = [2,8]
remaining_indices3 = [k for k=1:size(duck,2) if k ∉ outlier_indices3]
```

Since we apply these outliers after rotation, one way to illustrate them on the `duck` is to rotate them back and draw that into the original data.

```{julia}
#| output: false
outlier_shifts3_rp = [R(-α_true)x for x in outlier_shifts3]
outlier_lines3 = [
    [
        [
            duck[xy,outlier_indices3[k]],
            duck[xy,outlier_indices3[k]] + outlier_shifts3_rp[k][xy]
        ] for xy = 1:2
    ]
    for k=1:length(outlier_indices3)
]
```
```{julia}
#| echo: false
#| code-fold: true
#| output: false
for (i,v) in enumerate(outlier_shifts3_rp)
    export_point_data(
        sub_experiment3*"-orig-outlier$(i).csv",
        hcat(duck[:,outlier_indices3[i]], duck[:,outlier_indices3[i]] .+ outlier_shifts3_rp[i])
    )
end
```

```{julia}
outliers3_rotated_duck = copy(rotated_duck)
    # generate outliers on the rotated duck
    for (i,k) in enumerate(outlier_indices3)
        outliers3_rotated_duck[:,k] += outlier_shifts3[i]
    end
```

We compute the minimizers

```{julia}
p3F = Frobenius_minimizer(duck, outliers3_rotated_duck)
p3S = spectral_minimizer(duck, outliers3_rotated_duck)
p3R = robust_minimizer(duck, outliers3_rotated_duck)
nothing
```

and we generate the rotated results

```{julia}
#| output: false
duck3F = p3F * outliers3_rotated_duck
duck3S = p3S * outliers3_rotated_duck
duck3R = p3R * outliers3_rotated_duck
```

The result is

```{julia}
    res3_fig = Figure()
    res3_ax = Axis(res3_fig[1, 1], title="Reconstructing the duck “$(sub_experiment3)” ")
    scatter!(res3_ax, duck[1,:], duck[2,:], label="a duck", color=color_duck, markersize=20)
    for k=1:length(outlier_indices3)
        lines!(res3_ax, outlier_lines3[k][1], outlier_lines3[k][2], color=:black)
    end
    scatter!(res3_ax, duck3F[1,:], duck3F[2,:], label="Frobenius result", color=color_Frobenius, markersize=10)
    scatter!(res3_ax, duck3S[1,:], duck3S[2,:], label="Spectral result", color=color_spectral, markersize=10)
    scatter!(res3_ax, duck3R[1,:], duck3R[2,:], label="Robust result", color=color_robust, markersize=10)
    axislegend(res3_ax,position = :rb)
    res3_fig
```

## Experiment 4: Outliers of rank 1

Next we consider a rank-1 update from the nullspace of the `duck`.

```{julia}
#| output: false
sub_experiment4 = "spectral"
singular_duck = svd(duck)
V = nullspace(duck)
v = 1/size(V,2) * sum(V, dims=2)
u = [1.0, 1.0]
vt_shift4 = u*v'
outlier_shifts4_all = [ vt_shift4[:,i] for i in 1:size(singular_duck.Vt,2) ]
outlier_indices4 = filter(
    (i) -> norm(outlier_shifts4_all[i])>1e-13,
    collect(1:length(outlier_shifts4_all))
)
σ = 8.0
outlier_shifts4 = [ σ*outlier_shifts4_all[i] for i in outlier_indices4]
remaining_indices4 = [k for k=1:size(duck,2) if k ∉ outlier_indices4]
```

Since we apply these outliers after rotation, one way to illustrate them on the `duck` is to rotate them back and draw that into the original data.

```{julia}
#| output: false
outlier_shifts4_rp = [R(-α_true)x for x in outlier_shifts4]
outlier_lines4 = [
    [
        [
            duck[xy,outlier_indices4[k]],
            duck[xy,outlier_indices4[k]] + outlier_shifts4_rp[k][xy]
        ] for xy = 1:2
    ]
    for k=1:length(outlier_indices4)
]
```
```{julia}
#| echo: false
#| code-fold: true
#| output: false
for (i,v) in enumerate(outlier_shifts4_rp)
    export_point_data(
        sub_experiment4*"-orig-outlier$(i).csv",
        hcat(duck[:,outlier_indices4[i]], duck[:,outlier_indices4[i]] .+ outlier_shifts4_rp[i])
    )
end
```

```{julia}
outliers4_rotated_duck = copy(rotated_duck)
# generate outliers on the rotated duck
for (i,k) in enumerate(outlier_indices4)
    outliers4_rotated_duck[:,k] += outlier_shifts4[i]
end
```

We compute the minimizers

```{julia}
p4F = Frobenius_minimizer(duck, outliers4_rotated_duck)
p4S = spectral_minimizer(duck, outliers4_rotated_duck)
p4R = robust_minimizer(duck, outliers4_rotated_duck)
nothing
```

and we generate the rotated results

```{julia}
#| output: false
duck4F = p4F * outliers4_rotated_duck
duck4S = p4S * outliers4_rotated_duck
duck4R = p4R * outliers4_rotated_duck
```

The result is

```{julia}
    res4_fig = Figure()
    res4_ax = Axis(res4_fig[1, 1], title="Reconstructing the duck “$(sub_experiment4)” ")
    scatter!(res4_ax, duck[1,:], duck[2,:], label="a duck", color=color_duck, markersize=20)
    for k=1:length(outlier_indices4)
        lines!(res4_ax, outlier_lines4[k][1], outlier_lines4[k][2], color=:black)
    end
    scatter!(res4_ax, duck4F[1,:], duck4F[2,:], label="Frobenius result", color=color_Frobenius, markersize=10)
    scatter!(res4_ax, duck4S[1,:], duck4S[2,:], label="Spectral result", color=color_spectral, markersize=10)
    scatter!(res4_ax, duck4R[1,:], duck4R[2,:], label="Robust result", color=color_robust, markersize=10)
    axislegend(res4_ax,position = :rt)
    res4_fig
```

```{julia}
#| echo: false
#| code-fold: true
#| output: false
write_png && save(folder*experiment_name*sub_experiment3*"_results.png",res3_fig)
```

## Experiment 5: Outliers of rank 1 plus uniform noise

Next we consider a rank-1 update from the nullspace of the `duck` and add uniform noise

```{julia}
#| output: false
sub_experiment5 = "spectral_and_uniform"
Random.seed!(23)
Rmat = 0.125*rand(size(duck)...)
vt_shift5 = u*v'.+ Rmat
outlier_shifts5_all = [ vt_shift5[:,i] for i in 1:size(singular_duck.Vt,2) ]
outlier_indices5 = filter(
    (i) -> norm(outlier_shifts5_all[i])>1e-13,
    collect(1:length(outlier_shifts5_all))
)
σ = 4.0
outlier_shifts5 = [ σ*outlier_shifts5_all[i] for i in outlier_indices5]
remaining_indices5 = [k for k=1:size(duck,2) if k ∉ outlier_indices5]
```

Since we apply these outliers after rotation, one way to illustrate them on the `duck` is to rotate them back and draw that into the original data.

```{julia}
#| output: false
outlier_shifts5_rp = [R(-α_true)x for x in outlier_shifts5]
outlier_lines5 = [
    [
        [
            duck[xy,outlier_indices5[k]],
            duck[xy,outlier_indices5[k]] + outlier_shifts5_rp[k][xy]
        ] for xy = 1:2
    ]
    for k=1:length(outlier_indices5)
]
```
```{julia}
#| echo: false
#| code-fold: true
#| output: false
for (i,v) in enumerate(outlier_shifts5_rp)
    export_point_data(
        sub_experiment5*"-orig-outlier$(i).csv",
        hcat(duck[:,outlier_indices5[i]], duck[:,outlier_indices5[i]] .+ outlier_shifts5_rp[i])
    )
end
```

```{julia}
outliers5_rotated_duck = copy(rotated_duck)
# generate outliers on the rotated duck
for (i,k) in enumerate(outlier_indices5)
    outliers5_rotated_duck[:,k] += outlier_shifts5[i]
end
```

We compute the minimizers

```{julia}
p5F = Frobenius_minimizer(duck, outliers5_rotated_duck)
p5S = spectral_minimizer(duck, outliers5_rotated_duck)
p5R = robust_minimizer(duck, outliers5_rotated_duck)
nothing
```

and we generate the rotated results

```{julia}
#| output: false
duck5F = p5F * outliers5_rotated_duck
duck5S = p5S * outliers5_rotated_duck
duck5R = p5R * outliers5_rotated_duck
```

The result is

```{julia}
    res5_fig = Figure()
    res5_ax = Axis(res5_fig[1, 1], title="Reconstructing the duck “$(sub_experiment5)” ")
    scatter!(res5_ax, duck[1,:], duck[2,:], label="a duck", color=color_duck, markersize=20)
    for k=1:length(outlier_indices5)
        lines!(res5_ax, outlier_lines5[k][1], outlier_lines5[k][2], color=:black)
    end
    scatter!(res5_ax, duck5F[1,:], duck5F[2,:], label="Frobenius result", color=color_Frobenius, markersize=10)
    scatter!(res5_ax, duck5S[1,:], duck5S[2,:], label="Spectral result", color=color_spectral, markersize=10)
    scatter!(res5_ax, duck5R[1,:], duck5R[2,:], label="Robust result", color=color_robust, markersize=10)
    axislegend(res5_ax,position = :rt)
    res5_fig
```

```{julia}
#| echo: false
#| code-fold: true
#| output: false
#= copy of old Pluto notebook code that still has to be adopted here to run.

# ╔═╡ 3b47eb93-cd27-4c76-8d62-0c3b83b8414f
s_duck = svd(duck)

# ╔═╡ 62bcf78c-0464-44db-94af-f29fb3b2bdab
md"""
We will use the following prefixed
* o – includes outliers
* r – rotated
"""

# ╔═╡ 0ea83015-dfd7-4c17-8a68-bad0d118ea90
md"""
## Parameters
"""

# ╔═╡ 5fbc8c14-3369-45f4-a441-74eeddac5c94
# How much is the data rotated (for best of cases we aim to get α back)
α_true = 5π/8

# ╔═╡ 3322f99e-9e51-4be7-a815-5ce6492045d3
duck_c = duck .- mean(duck; dims=2)

# ╔═╡ d5232a33-6df1-410d-b12c-5f96344ce8b5
begin
    if sub_name ∈ ["even", "orth", "any"]
        # Form the 10 indices – which ones are outliers?
        outlier_indices = [2,8]
        (sub_name == "even") && (outlier_shifts = [[2.0, 0.0], [0.0,2.0]])
        (sub_name == "orth") && (outlier_shifts = [[1.0, 0.0], [0.0,2.0]])
        (sub_name == "any") && (outlier_shifts = [[1.0, 2.0], [0.0,2.0]])
        σ = 1.0
    end
    if sub_name == "spectral"
        # Rank-1 alternatives - orthogonal to the data or in other words from the nullspace
        V = nullspace(duck)
        v = 1/size(V,2) * sum(V, dims=2)
        u = [1.0, 1.0]
        vt_shift = u*v'
         outlier_shifts_all = [ vt_shift[:,i] for i in 1:size(s_duck.Vt,2) ]
        outlier_indices = filter(
            (i) -> norm(outlier_shifts_all[i])>1e-13,
            collect(1:length(outlier_shifts_all))
        )
        σ = 8.0
        outlier_shifts = [ σ*outlier_shifts_all[i] for i in outlier_indices]
        # add a bit of Gaussian noise on the other
    end
    if sub_name == "spectral_and_gaussian" || sub_name == "spectral_and_uniform"
        V = nullspace(duck)
        v = 1/size(V,2) * sum(V, dims=2)
        u = [1.0, 1.0]
        Rmat = if sub_name == "spectral_and_gaussian"
            Random.seed!(23)
            0.05*randn(size(duck)...)
        else
            Random.seed!(23)
            0.125*rand(size(duck)...)
        end
        vt_shift = u*v' .+ Rmat
        outlier_shifts_all = [ vt_shift[:,i] for i in 1:size(s_duck.Vt,2) ]
        outlier_indices = filter(
            (i) -> norm(outlier_shifts_all[i])>1e-13,
            collect(1:length(outlier_shifts_all))
        )
        σ = 4.0
        outlier_shifts = [σ*outlier_shifts_all[i] for i in outlier_indices]
        # add a bit of Gaussian noise on the other
    end
    outlier_shifts
end

# ╔═╡ aab59fbd-702e-49e8-8bca-7598f3665839
outlier_indices

# ╔═╡ 105ba7ab-a6e9-4f02-b453-cd4e4b9f1bea
md"## Small Helper functions"

# ╔═╡ b1ab4a1d-8f1d-4a50-a02d-6fa7cc4f9c4e
remaining_indices = [k for k=1:size(duck,2) if k ∉ outlier_indices]

# ╔═╡ f1d23ece-b9d9-471c-a252-4ade21286aa6
R(α) = [cos(α) sin(α); -sin(α) cos(α)]

# ╔═╡ 17065b72-7e33-4c41-8fef-45a1b0ba09df
# For each outlier – move them back to the original (A) space to draw lines
outlier_shifts_rp = [R(-α_true)x for x in outlier_shifts]

# ╔═╡ 8d9eccdf-bba2-4b94-ad0a-c2b8b634b305
for (i,v) in enumerate(outlier_shifts_rp)
    export_data(sub_name*"-orig-outlier$(i).csv", hcat(duck[:,outlier_indices[i]], duck[:,outlier_indices[i]] .+ outlier_shifts_rp[i]))
end

# ╔═╡ 2479e210-8d21-4f24-9dbf-e93bf61a479d
# For plotting add outlier lines first X then y components
outlier_lines = [
    [
        [
            duck[xy,outlier_indices[k]],
            duck[xy,outlier_indices[k]] + outlier_shifts_rp[k][xy]
        ] for xy = 1:2
    ]
    for k=1:length(outlier_indices)
]

# ╔═╡ 574fe359-d0e4-4082-b3a6-e0af7b091704
α(R) = atan(R[2,1], R[1,1])

# ╔═╡ 7d78b5be-b536-4320-a3ea-17cedeb50c76
error_on_nonoutliers(res) = norm(res[:,remaining_indices]-duck[:,remaining_indices])

# ╔═╡ 4b3771b6-d66c-4f43-9af4-13c6eb007f4f
md"""
## True solution and a first plot of outliers
"""

# ╔═╡ aa792ccb-1bcd-4f52-a273-282dae1d6ceb
p_true = R(-α_true) # Point on SO(2), the true reconstruction point we aim for

# ╔═╡ c583e450-b085-456c-a5f5-c7cb087f5c0c
r_duck = p_true'*duck

# ╔═╡ 6e313f7f-371a-43a1-888c-63f7c92eb804
export_data("-rotated.csv", r_duck)

# ╔═╡ f5f4e193-65bc-4864-b081-c711df7a8294
begin
    o_fig = Figure()
    o_ax = Axis(o_fig[1, 1])
    scatter!(o_ax, duck[1,:], duck[2,:], label="a duck")
    for k=1:length(outlier_indices)
        lines!(o_ax, outlier_lines[k][1], outlier_lines[k][2], color=:black)
    end
    axislegend(o_ax,position = :rt)
    save(folder*experiment*sub_name*"-outlier-plot.png",o_fig)
    o_fig
end

# ╔═╡ 860811cd-e3b9-42f4-a366-dd2d0b15dff2
md"""
## Manifolds and costs
"""

# ╔═╡ 6b0fb1b2-d944-4cfa-83f1-19654c8f7300
function Frobenius_minimizer(A,B)
    svd_AB = svd(A*B')
    return svd_AB.U*svd_AB.V'
end

# ╔═╡ 3508f082-9c52-4d9e-b765-f90d094d7fb0
M = Rotations(2)

# ╔═╡ 33a822b6-96f2-411a-a55e-d55686012fcc
md"""
We consider the following three costs
"""

# ╔═╡ 463c26a6-a9a9-490f-ad5e-303023c7e438
@doc raw"""
    Spectral_cost(M, p)

Compute the spectral norm ``\lVert p\cdot B- A\rVert_2``.
"""
Spectral_cost(M, p; B=r_duck, A=duck) = opnorm(p*B - A)

# ╔═╡ e7fae1c9-4800-4db4-bc66-24d0b89f24da
@doc raw"""
    Frobenius_cost(M, p)

Compute the Frobenious norm ``\lVert p\cdot B- A\rVert_{\mathrm{F}}``.
"""
Frobenius_cost(M, p; B=r_duck, A=duck) = norm(p*B - A)

# ╔═╡ f5f795c2-a25f-48b3-86b8-ee43827eb719
@doc raw"""
    TwoOne_cost(M, p)

Compute the 2-1-norm ``\lVert p\cdot B- A\rVert_{2,1}``, i.e. the sum of the 2-norms of the columns.
"""
Robust_cost(M,p; B=r_duck, A=duck) = sum([norm(c, 2.0) for c in eachcol(p*B-A)])

# ╔═╡ e747aba5-1272-4e71-beac-01ebf46ac567
p0 = Matrix{Float64}(I,2,2)

# ╔═╡ 5f1b13c3-28dc-4ea6-93b1-7a43eaf2999a
begin
    or_duck = copy(r_duck)
    # Here we first rotated and then do outliers
    for (i,k) in enumerate(outlier_indices)
        or_duck[:,k] += outlier_shifts[i]
    end
end

# ╔═╡ dd4e4dd8-6c57-4de5-a403-7aca2c3958f3
export_data(sub_name*"-rotated-outliers.csv", or_duck)

# ╔═╡ 7943b063-0c48-481c-b484-202321d92814
# ╠═╡ disabled = true
#=╠═╡
#For now we do not need this data, so we deactivate this cell
for (i,k) in enumerate(outlier_indices)
    export_data(sub_name*"-rotated-outlier$(i).csv", hcat(r_duck[:,k], or_duck[:,k]))
end
  ╠═╡ =#

# ╔═╡ 8feb0e44-e682-485b-a3be-fe1b8a199ad7
md"""
## Part II: Optimize
"""

# ╔═╡ 5164467b-5e6f-444a-aca2-c2598bc42b3d
@time p_or_S = mesh_adaptive_direct_search(
    M,
    (M,p) -> Spectral_cost(M, p; B=or_duck), p0;
    debug=[:Iteration, :Cost, "\n", 10, :Stop]
);

# ╔═╡ e547b71b-cf0f-44b8-a5d6-bdaa4d307e79
duck1S = p_or_S*or_duck;

# ╔═╡ 76fcb6a6-5dd1-4e2b-88e4-5e5411e2e5b8
export_data(sub_name*"-Result-S.csv", duck1S)

# ╔═╡ ab729e50-8326-4018-b150-a4023787468e
duck

# ╔═╡ 88f9034d-58f4-4c2d-a505-41ca5720dfc7
p_or_F = Frobenius_minimizer(duck, or_duck);

# ╔═╡ 371d930c-5e6a-4d9e-a85f-54797c4e7d85
duck1F = p_or_F*or_duck;

# ╔═╡ c4820d1d-cd44-4967-bbd1-8c613c2c852b
export_data(sub_name*"-Result-F.csv", duck1F)

# ╔═╡ b3761be4-d665-437f-861b-6cc34bc357c5
@time p_or_R = mesh_adaptive_direct_search(
    M,
    (M,p) -> Robust_cost(M, p; B=or_duck), p0;
    debug=[:Iteration, :Cost, "\n", 10, :Stop]
);

# ╔═╡ c7a11d05-28ae-4ad8-af92-a7ab1b58e629
duck1R = p_or_R*or_duck;

# ╔═╡ 780967e2-e41e-48ed-af7d-f7c61655a1d8
export_data(sub_name*"-Result-T.csv", duck1R)

# ╔═╡ b55efc6e-e406-44ee-9f4d-bb80ac5af009
begin
    or_fig = Figure()
    or_ax = Axis(or_fig[1, 1], title="Reconstructing the duck (close to outlier is best)")
    scatter!(or_ax, duck[1,:], duck[2,:], label="a duck")
    for k=1:length(outlier_indices)
        lines!(or_ax, outlier_lines[k][1], outlier_lines[k][2], color=:black)
    end
    scatter!(or_ax, duck1S[1,:], duck1S[2,:], label="Spectral result")
    scatter!(or_ax, duck1F[1,:], duck1F[2,:], label="Frobenius result")
    scatter!(or_ax, duck1R[1,:], duck1R[2,:], label="Robust result")
    axislegend(or_ax,position = :rt)
    save(folder*experiment*sub_name*"-reconstr-plot.png",or_fig)
    or_fig
end

# ╔═╡ 372c41d2-481b-43a2-8270-5dd7241f6e8a
md"""
## Analysis
"""

# ╔═╡ bf539b19-b6c7-4127-8e09-8af9d3346c5a
# Angles
[α_true, α(p_or_S), α(p_or_F), α(p_or_R)]

# ╔═╡ 372bc020-0ba3-4643-9133-f1dbc74b1852
# Angle errors
[α(p_or_S), α(p_or_F), α(p_or_R)] .- α_true

# ╔═╡ f7f66ffe-1397-4b4f-bf0b-8aef295c57e3
# Error on non-outlier points
# (for spectral this is zero since all are moved)
[error_on_nonoutliers(d) for d in [duck1S, duck1F, duck1R]]

# ╔═╡ b363e5c6-a164-4c8d-91ed-dd0209e9d645
# Plot costs vs angle
x = range(-π,π,300)

# ╔═╡ 4eba422f-5c66-4632-a2dc-ffae0d684f94
cost_S = map( p -> Spectral_cost(M, p; B=or_duck), R.(x))

# ╔═╡ 4b5ee2d4-6139-4840-bce9-d922a9f50c22
cost_R = map( p -> Robust_cost(M, p; B=or_duck), R.(x))

# ╔═╡ 33fad395-a956-45d5-81b5-bb3bfb60d800
cost_F = map( p -> Frobenius_cost(M, p; B=or_duck), R.(x))

# ╔═╡ 66f9ec18-947c-4da4-80e2-9a1d6c079223
#plot them
begin
    cost_fig = Figure()
    cost_ax = Axis(cost_fig[1, 1], title="Cost over Rotation angle "*sub_name)
    # alpha true - to see how close we got / or could get
    vlines!(cost_ax, [-α_true], linestyle=:dash, label="true angle")
    lines!(cost_ax, x, cost_S, label="Spectral")
    lines!(cost_ax, x, cost_F, label="Frobenius")
    lines!(cost_ax, x, cost_R, label="Robust")
    # Plot minimizers
    scatter!(cost_ax, [α(p_or_S'),], [Spectral_cost(M, p_or_S; B=or_duck),])
    scatter!(cost_ax, [α(p_or_F'),], [Frobenius_cost(M, p_or_F; B=or_duck),])
    scatter!(cost_ax, [α(p_or_R'),], [Robust_cost(M, p_or_R; B=or_duck),])
    axislegend(cost_ax,position = :rc)
    save(folder*experiment*sub_name*"-rcost-plot.png",cost_fig)
    cost_fig
end

# ╔═╡ 506179e0-1c3d-4d26-b609-9191463ba16c
export_csv && CSV.write(
    folder*experiment*sub_name*"-cost-data.csv",
    DataFrame(x=x, S=cost_S, F=cost_F, R=cost_R)
)

# ╔═╡ 3a9e582f-4f95-44d3-b9e3-7e3f2c877339
export_csv && CSV.write(
    folder*experiment*sub_name*"-cost-minimisers.csv",
    DataFrame(xS=[α(p_or_S'),], yS=[Spectral_cost(M, p_or_S; B=or_duck),],
             xF=[α(p_or_F'),], yF = [Frobenius_cost(M, p_or_F; B=or_duck),],
             xR=[α(p_or_R'),], yR=[Robust_cost(M, p_or_R; B=or_duck),],
             yFinS = [Spectral_cost(M, p_or_F; B=or_duck),],
             yFinR = [Robust_cost(M, p_or_F; B=or_duck),],
    )
)

=#
```

## Technical details

This tutorial is cached. It was last run on the following package versions.

```{julia}
#| code-fold: true
#| code-summary: "Package versions"
#| echo: false
using Pkg
Pkg.status()
```

```{julia}
#| echo: false
#| output: asis
using Dates
println("This tutorial was last rendered $(Dates.format(now(), "U d, Y, H:M:S")).");
```