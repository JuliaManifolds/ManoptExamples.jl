---
title: "Geodesic under Force Field on the Sphere"
author: "Laura Weigl, Ronny Bergmann, and Anton Schiela"
date: 2025-07-13
---

```{julia}
#| echo: false
#| output: false
# TODO: Change once `vectorbundle_newton` is released in `Manopt.jl`
using Pkg;
Pkg.activate("."); # for reproducibility use the local tutorial environment.
Pkg.develop(; path="../../Manopt.jl") # a trick to work on the local dev version
```

```{julia}
using LinearAlgebra, SparseArrays, OffsetArrays
using Manifolds, Manopt, ManoptExamples
using GLMakie, Makie, GeometryTypes, Colors, ColorSchemes, NamedColors
using CSV, DataFrames
```

# Introduction

In this example we compute a geodesic under a force field on the sphere by applying Newton's method on vector bundles which was introduced in \ref{paper}. This example reproduces the results from \ref{paper}.

We consider the sphere $\mathbb{S}^2$ equipped with the Riemannian metric $\langle \cdot, \cdot \rangle$ given by the Euclidean inner product with corresponding norm $\lVert\cdot\rVert$ and an interval $\Omega \subset \mathbb R$.
Let $\mathcal X = H^1(\Omega, \mathbb S^2)$ and  $\mathcal E^* = T^*\mathcal X$ its cotangent bundle.

Our goal is to find a zero of the mapping $F \colon \mathcal X \to \mathcal E^*$ with

$F(\gamma)\phi \coloneqq \int_\Omega \langle\dot{\gamma}(t), \dot{\phi}(t)\rangle + \omega(\gamma(t))\phi(t) \; dt$

for $\gamma \in \mathcal X$ and $\phi \in T_\gamma\mathcal X$.

Additionally, we have to take into account that boundary conditions $\gamma(0) = \gamma_0$ and $\gamma(T) = \gamma_T$ for given $\gamma_0, \gamma_T \in \mathbb S^2$ are satisfied.
This yields a geodesic under a given force field $\omega\colon \mathbb S^2 \to T^*\mathbb S^2$ connecting $\gamma_0$ and $\gamma_T$.

For our example we set

```{julia}
    N = 50
    S = Manifolds.Sphere(2)
    power = PowerManifold(S, NestedPowerRepresentation(), N)

    mutable struct variational_space
		manifold::AbstractManifold
		degree::Integer
	end

	test_space = variational_space(S, 1)

    start_interval = 0.4
	end_interval = pi - 0.4
	discrete_time = range(; start = start_interval, stop = end_interval, length=N+2) # equidistant discrete time points
	
	y0 = [sin(start_interval),0,cos(start_interval)] # startpoint of geodesic
	yT = [sin(end_interval),0,cos(end_interval)] # endpoint of geodesic
```

As a starting point, we use the geodesic connecting $\gamma_0$ and $\gamma_T$:

```{julia}
y(t) =  [sin(t), 0, cos(t)]
discretized_y = [y(ti) for ti in discrete_time[2:end-1]]
```

In order to apply Newton's method to find a zero of $F$, we need the linear mapping $Q_{F(\gamma)}^*\circ F'(\gamma)$ ``[WeiglBergmannSchiela:2025](@cite)``{=commonmark} which can be seen as a covariant derivative.
Since the sphere is an embedded submanifold of $\mathbb R^3$, we can use the formular
$Q_{F(\gamma)}^*\circ F'(\gamma)\delta \gamma\,\phi = F(\gamma)(\overset{\rightarrow}{V}_\gamma'(\gamma)\delta \gamma\,\phi) + F_{\mathbb R^3}'(\gamma)\delta \gamma\,\phi$
for $\delta \gamma, \, \phi \in T_\gamma \mathcal X$, where $\overset{\rightarrow}{V}_\gamma(\hat \gamma) \in L(T_\gamma \mathcal X, T_{\hat{\gamma}}\mathcal X)$ is a vector transport and
$F_{\mathbb R^3}'(\gamma)\delta \gamma\, \phi = \int_\Omega \langle \dot{\delta \gamma}(t),\dot{\phi}(t)\rangle + \omega'(\gamma(t))\delta \gamma(t)\phi(t) \; dt$
is the euclidean derivative of $F$.

We define a structure that has to be filled for two purposes:
* Definition of an integrand and its derivative
* Definition of a vector transport and its derivative

```{julia}
mutable struct DifferentiableMapping{F1<:Function,F2<:Function,T}
    value::F1
    derivative::F2
    scaling::T
end;
```

md"""
The following routines define a vector transport and its euclidean derivative. As seen above, they are needed to derive a covariant derivative of $F$.

As a vector transport we use the (pointwise) orthogonal projection onto the tangent spaces, i.e. for $p, q \in \mathbb S^2$ and $X \in T_p\mathbb S^2$ we set
$\overset{\rightarrow}{V}_{p}(q)X = (I-q\cdot q^T)X \in T_q\mathbb S^2.$
The derivative of the vector transport is then given by
$\left(\frac{d}{dq}\overset{\rightarrow}{V}_{p}(q)\big\vert_{q=p}\delta q\right)X = \left( - \delta q\cdot p^T - p\cdot \delta q^T\right)\cdot X.$
```{julia}
function transport_by_proj(S, p, X, q)
    return X - q*(q'*X)
end
function transport_by_proj_prime(S, p, X, dq)
    return (- dq*p' - p*dq')*X
end
transport=DifferentiableMapping(transport_by_proj,transport_by_proj_prime,nothing)
```

The following two routines define the integrand of $F$ and its euclidean derivative.
They use a force field $\omega$, which is defined, below. A scaling parameter for the force is also employed.

In this example we consider the force field $\omega\colon \mathbb S^2 \to T^*\mathbb S^2$ given by the 1-form corresponding to a (scaled) winding field, i.e. for $C\in\mathbb R$ and $y\in \mathbb{S}^2$ we set $\omega(y) \coloneqq \frac{C y_3}{y_1^2+y_2^2} \cdot \bigg\langle \begin{pmatrix} -y_2 \\ y_1 \\ 0 \end{pmatrix}, \cdot \bigg\rangle \in (T_y\mathbb{S}^2)^*.$

```{julia}
w(p, c) = c*p[3]*[-p[2]/(p[1]^2+p[2]^2), p[1]/(p[1]^2+p[2]^2), 0.0];
```

Its derivative is given by

```{julia}
function w_prime(p, c)
	denominator = p[1]^2+p[2]^2
	
	return c*[p[3]*2*p[1]*p[2]/denominator^2 p[3]*(-1.0/denominator+2.0*p[2]^2/denominator^2) -p[2]/denominator; p[3]*(1.0/denominator-2.0*p[1]^2/(denominator^2)) p[3]*(-2.0*p[1]*p[2]/(denominator^2)) p[1]/denominator; 0.0 0.0 0.0]
end;
```

```{julia}
function F_at(Integrand, y, ydot, B, Bdot)
    return ydot'*Bdot+w(y,Integrand.scaling)'*B
end
function F_prime_at(Integrand,y,ydot,B1,B1dot,B2,B2dot)
    return B1dot'*B2dot+(w_prime(y,Integrand.scaling)*B1)'*B2
end
integrand=DifferentiableMapping(F_at,F_prime_at,3.0)
```

## Newton Equation

In this example we implement a functor to compute the Newton matrix and the right hand side for the Newton equation ``[WeiglBergmannSchiela:2025](@cite)``
```math
Q^*_{F(\gamma)}\circ F'(\gamma)\delta \gamma + F(\gamma) = 0
```

by using the assembler provided in ManoptExamples.jl (cf. Referenz).

It returns the matrix and the right hand side in base representation.
Moreover, for the computation of the simplified Newton direction (which is necessary for affine covariant damping) a method for assembling the right hand side for the simplified Newton equation is provided.

The assembly routines need a function for evaluation the iterates at the left and right quadrature point.

```{julia}
evaluate(p, i, tloc) = (1.0-tloc)*p[i-1]+tloc*p[i];

struct NewtonEquation{F, TS, T, I, NM, Nrhs}
	integrand::F
	test_space::TS
	transport::T
	time_interval::I
	A::NM
	b::Nrhs
end

function NewtonEquation(M, F, test_space, VT, interval)
	n = manifold_dimension(M)
	A = spzeros(n,n)
	b = zeros(n)
	return NewtonEquation{typeof(F), typeof(test_space), typeof(VT), typeof(interval), typeof(A), typeof(b)}(F, test_space, VT, interval, A, b)
end

function (ne::NewtonEquation)(M, VB, p)
	n = manifold_dimension(M)
	ne.A .= spzeros(n,n)
	ne.b .= zeros(n)

	Op = OffsetArray([y0, p..., yT], 0:(length(p)+1))
	
	ManoptExamples.get_jacobian!(M, Op, evaluate, ne.A, ne.integrand, ne.transport, ne.time_interval; test_space = ne.test_space)
	ManoptExamples.get_right_hand_side!(M, Op, evaluate, ne.b, ne.integrand, ne.time_interval; test_space = ne.test_space)
end

function (ne::NewtonEquation)(M, VB, p, p_trial)
	n = manifold_dimension(M)
	btrial=zeros(n)
	
	Op = OffsetArray([y0, p..., yT], 0:(length(p)+1))
	Optrial = OffsetArray([y0, p_trial..., yT], 0:(length(p_trial)+1))

	ManoptExamples.get_right_hand_side_simplified!(M, Op, Optrial, evaluate, btrial, ne.integrand, ne.transport, ne.time_interval; test_space = ne.test_space)
	
	return btrial
end
```

We compute the Newton direction $\delta \gamma$ by solving the linear system given by the base representation of the Newton equation directly and return the Newton direction in vector representation:

```{julia}
function solve_in_basis_repr(problem, newtonstate)
    X_base = (problem.newton_equation.A) \ (-problem.newton_equation.b)
    return get_vector(problem.manifold, newtonstate.p, X_base, DefaultOrthogonalBasis())
end
```

We adjust the norms for recording
```{julia}
	rec = RecordChange(power;
    inverse_retraction_method=ProjectionInverseRetraction());
```

```{julia}
begin
    NE = NewtonEquation(power, integrand, test_space, transport, discrete_time)

    st_res = vectorbundle_newton(power, TangentBundle(power), NE, discretized_y; sub_problem=solve_in_basis_repr,
	stopping_criterion=(StopAfterIteration(150)|StopWhenChangeLess(power,1e-12; outer_norm=Inf, inverse_retraction_method=ProjectionInverseRetraction())),
	retraction_method=ProjectionRetraction(),
	debug=[:Iteration, (:Change, "Change: %1.8e"), "\n", :Stop, (:Stepsize, "Stepsize: %1.8e"), "\n",],
	record=[:Iterate, rec => :Change],
	return_state=true
    )
end
```

We extract the recorded values

```{julia}
    change = get_record(st_res, :Iteration, :Change)[2:end]
    p_res = get_solver_result(st_res)
```

and plot the result, where we measure the norms of the Newton direction in each iteration,

```{julia}
f = Figure(;)
row, col = fldmod1(1, 2)
Axis(f[row, col], yscale = log10, title = string("Norms of the Newton directions (semilogarithmic)"), xminorgridvisible = true, xticks = (1:length(change)), xlabel = "Iteration", ylabel = "‖δx‖")
scatterlines!(change[1:end], color = :blue)
f
```

and the resulting geodesic under the force field (orange).
The starting geodesic (blue) is plotted as well. The force acting on each point of the geodesic is visualized by green arrows.

```{julia}
n = 25
u = range(0; stop=2 * π, length=n);
v = range(0; stop=π, length=n);
sx = zeros(n, n);
sy = zeros(n, n);
sz = zeros(n, n);

ws = [-w(p, integrand.scaling) for p in p_res]
ws_start = [-w(p, integrand.scaling) for p in discretized_y]
for i in 1:n
    for j in 1:n
        sx[i, j] = cos.(u[i]) * sin(v[j])
        sy[i, j] = sin.(u[i]) * sin(v[j])
        sz[i, j] = cos(v[j])
    end
end
fig, ax, plt = meshscatter(
    sx, sy, sz; color=RGBA(1.0, 1.0, 1.0, 0.0), shading=Makie.automatic, transparency=true
)
geodesic_start = [y0, discretized_y..., yT]
geodesic_final = [y0, p_res..., yT]
ax.show_axis = false
wireframe!(ax, sx, sy, sz; color=RGBA(0.5, 0.5, 0.7, 0.1), transparency=true)
π1(x) = 1.02 * x[1]
π2(x) = 1.02 * x[2]
π3(x) = 1.02 * x[3]
scatterlines!(
    ax,
    π1.(geodesic_final),
    π2.(geodesic_final),
    π3.(geodesic_final);
    markersize=5,
    color=:orange,
    linewidth=2,
)
scatterlines!(
    ax,
    π1.(geodesic_start),
    π2.(geodesic_start),
    π3.(geodesic_start);
    markersize=5,
    color=:blue,
    linewidth=2,
)
scatter!(ax, π1.([y0, yT]), π2.([y0, yT]), π3.([y0, yT]); markersize=5, color=:red)
arrows!(
    ax,
    π1.(p_res),
    π2.(p_res),
    π3.(p_res),
    π1.(ws),
    π2.(ws),
    π3.(ws);
    color=:green,
    linewidth=0.01,
    arrowsize=Vec3f(0.03, 0.03, 0.05),
    transparency=true,
    lengthscale=0.07,
)
cam = cameracontrols(ax.scene)
cam.lookat[] = [-2.5, 2.5, 2]
fig
```
