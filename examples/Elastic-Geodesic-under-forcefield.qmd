---
title: "Elastic Geodesic under Force Field on the Sphere"
author: "Laura Weigl, Ronny Bergmann, and Anton Schiela"
date: 2025-11-25
---

```{julia}
#| echo: false
#| output: false
using Pkg;
Pkg.activate("."); # for reproducibility use the local tutorial environment.
```

```{julia}
using LinearAlgebra, SparseArrays, OffsetArrays
using Manifolds, Manopt, ManoptExamples
using GLMakie, Makie, GeometryTypes, Colors, ColorSchemes, NamedColors
using CSV, DataFrames
```

# Introduction

In this example we compute an elastic geodesic under a force field on the sphere by applying Newton's method on vector bundles which was introduced in ``[WeiglBergmannSchiela:2025](@cite)``{=commonmark}. This example reproduces the results from the example in Section 6.1 therein.

We consider the sphere $\mathbb{S}^2$ equipped with the Riemannian metric $⟨  ⋅ ,  ⋅  ⟩$ given by the Euclidean inner product with corresponding norm $\lVert ⋅ \rVert$ and an interval $I ⊂ \mathbb R$.
Let $\mathcal X = H^1(I, \mathbb S^2)$ and  $\mathcal E^* = T^*\mathcal X$ its cotangent bundle.

Our goal is to find a zero of the mapping $F: \mathcal X → \mathcal E^*$ with

```math
F(γ)ϕ := \int_I ⟨\dot{γ}(t), \dot{ϕ}(t)⟩ + ω(γ(t))ϕ(t) \; \mathrm{d}t,
```
for $γ ∈ \mathcal X$ and $ϕ ∈ T_γ\mathcal X$.

Additionally, we have to take into account that boundary conditions $γ(0) = γ_0$ and $γ(T) = γ_T$ for given $γ_0, γ_T ∈ \mathbb S^2$ are satisfied.
This yields an elastic geodesic under a given force field $ω: \mathbb S^2 → T^*\mathbb S^2$ connecting $γ_0$ and $γ_T$.

For our example we set

```{julia}
    N = 50
    S = Manifolds.Sphere(2)
    power = PowerManifold(S, NestedPowerRepresentation(), N)

    mutable struct VariationalSpace
		manifold::AbstractManifold
		degree::Integer
	end

	test_space = VariationalSpace(S, 1)

    start_interval = 0.4
	end_interval = π - 0.4
	discrete_time = range(; start = start_interval, stop = end_interval, length=N+2) # equidistant discrete time points

	y0 = [sin(start_interval),0,cos(start_interval)] # startpoint of geodesic
	yT = [sin(end_interval),0,cos(end_interval)] # endpoint of geodesic
```

As a starting point, we use the geodesic connecting $γ_0$ and $γ_T$:

```{julia}
y(t) =  [sin(t), 0, cos(t)]
discretized_y = [y(ti) for ti in discrete_time[2:end-1]]
```

In order to apply Newton's method to find a zero of $F$, we need the linear mapping $Q_{F(γ)}^*∘ F'(γ)$ ``[WeiglBergmannSchiela:2025](@cite)``{=commonmark} which can be seen as a covariant derivative.
Since the sphere is an embedded submanifold of $\mathbb R^3$, we can use the formula
```math
Q_{F(γ)}^*∘ F'(γ)δ γ\,ϕ = F(γ)(\overset{→}{V}_γ'(γ)δ γ\,ϕ) + F_{\mathbb R^3}'(γ)δ γ\,ϕ
```
for $δ γ, \, ϕ ∈ T_γ \mathcal X$, where $\overset{→}{V}_γ(\hat γ) ∈ L(T_γ \mathcal X, T_{\hat{γ}}\mathcal X)$ is a vector transport and
$F_{\mathbb R^3}'(γ)δ γ\, ϕ = \int_I ⟨ \dot{δ γ}(t),\dot{ϕ}(t)⟩ + ω'(γ(t))δ γ(t)ϕ(t) \; \mathrm{d}t$
is the euclidean derivative of $F$.

We define a structure that has to be filled for two purposes:

1) Definition of an integrand and its derivative
2) Definition of a vector transport and its derivative

```{julia}
mutable struct DifferentiableMapping{F1<:Function,F2<:Function,T}
    value::F1
    derivative::F2
    scaling::T
end;
```

The following routines define a vector transport and its euclidean derivative. As seen above, they are needed to derive a covariant derivative of $F$.

As a vector transport we use the (pointwise) orthogonal projection onto the tangent spaces, i.e. for $p, q ∈ \mathbb S^2$ and $X ∈ T_p\mathbb S^2$ we set
math```
\overset{→}{V}_{p}(q)X = (I-q ⋅  q^T)X ∈ T_q\mathbb S^2.
```
The derivative of the vector transport is then given by
math```
\left(\frac{d}{dq}\overset{→}{V}_{p}(q)\big\vert_{q=p}δ q\right)X = \left( - δ q ⋅  p^T - p ⋅  δ q^T\right) ⋅  X.
```
```{julia}
transport_by_proj(S, p, X, q) =  X - q*(q'*X)

transport_by_proj_prime(S, p, X, dq) = (- dq*p' - p*dq')*X

transport=DifferentiableMapping(transport_by_proj,transport_by_proj_prime,nothing)
```

The following two routines define the integrand of $F$ and its euclidean derivative.
They use a force field $ω$, which is defined, below. A scaling parameter for the force is also employed.

In this example we consider the force field $ω: \mathbb S^2 → T^*\mathbb S^2$ given by the 1-form corresponding to a (scaled) winding field, i.e. for $C∈\mathbb R$ and $y∈ \mathbb{S}^2$ we set $ω(y) := \frac{C y_3}{y_1^2+y_2^2}  ⋅  \bigg⟨ \begin{pmatrix} -y_2 \\ y_1 \\ 0 \end{pmatrix},  ⋅  \bigg⟩ ∈ (T_y\mathbb{S}^2)^*.$

```{julia}
w(p, c) = c*p[3]*[-p[2]/(p[1]^2+p[2]^2), p[1]/(p[1]^2+p[2]^2), 0.0];
```

Its derivative is given by

```{julia}
function w_prime(p, c)
	denominator = p[1]^2+p[2]^2

	return c*[p[3]*2*p[1]*p[2]/denominator^2 p[3]*(-1.0/denominator+2.0*p[2]^2/denominator^2) -p[2]/denominator; p[3]*(1.0/denominator-2.0*p[1]^2/(denominator^2)) p[3]*(-2.0*p[1]*p[2]/(denominator^2)) p[1]/denominator; 0.0 0.0 0.0]
end;
```

```{julia}
F_at(Integrand, y, ydot, B, Bdot) = ydot'*Bdot+w(y,Integrand.scaling)'*B

F_prime_at(Integrand,y,ydot,B1,B1dot,B2,B2dot) = B1dot'*B2dot+(w_prime(y,Integrand.scaling)*B1)'*B2

integrand=DifferentiableMapping(F_at,F_prime_at,3.0)
```

## Newton Equation

In this example we implement a functor to compute the Newton matrix and the right hand side for the Newton equation ``[WeiglBergmannSchiela:2025](@cite)``{=commonmark}

```math
Q^*_{F(γ)}∘ F'(γ)δ γ + F(γ) = 0^*_γ
```

by using the assembler provided in `ManoptExamples.jl`.

It returns the matrix and the right hand side in base representation.

The assembly routines need a function for evaluation the iterates at the left and right quadrature point.

```{julia}
evaluate(p, i, tloc) = (1.0-tloc)*p[i-1]+tloc*p[i];

struct NewtonEquation{F, TS, T, I, NM, Nrhs}
	integrand::F
	test_space::TS
	transport::T
	time_interval::I
	A::NM
	b::Nrhs
end

function NewtonEquation(M, F, test_space, VT, interval)
	n = manifold_dimension(M)
	A = spzeros(n,n)
	b = zeros(n)
	return NewtonEquation{typeof(F), typeof(test_space), typeof(VT), typeof(interval), typeof(A), typeof(b)}(F, test_space, VT, interval, A, b)
end

function (ne::NewtonEquation)(M, VB, p)
	n = manifold_dimension(M)
	ne.A .= spzeros(n,n)
	ne.b .= zeros(n)

	Op = OffsetArray([y0, p..., yT], 0:(length(p)+1))

	ManoptExamples.get_jacobian!(M, Op, evaluate, ne.A, ne.integrand, ne.transport, ne.time_interval; test_space = ne.test_space)
	ManoptExamples.get_right_hand_side!(M, Op, evaluate, ne.b, ne.integrand, ne.time_interval; test_space = ne.test_space)
end
```

We compute the Newton direction $δ γ$ by solving the linear system given by the base representation of the Newton equation directly and return the Newton direction in vector representation:

```{julia}
function solve_in_basis_repr(problem, newtonstate)
    X_base = (problem.newton_equation.A) \ (-problem.newton_equation.b)
    return get_vector(problem.manifold, newtonstate.p, X_base, DefaultOrthogonalBasis())
end
```

We adjust the norms for recording
```{julia}
	rec = RecordChange(power;
    inverse_retraction_method=ProjectionInverseRetraction());
```

```{julia}
begin
    NE = NewtonEquation(power, integrand, test_space, transport, discrete_time)

    st_res = vectorbundle_newton(power, TangentBundle(power), NE, discretized_y; sub_problem=solve_in_basis_repr,
	stopping_criterion=( StopAfterIteration(150) | StopWhenChangeLess(power,1e-12; outer_norm=Inf, inverse_retraction_method=ProjectionInverseRetraction())),
	retraction_method=ProjectionRetraction(),
	debug=[:Iteration, (:Change, "Change: %1.8e"), "\n", :Stop, (:Stepsize, "Stepsize: %1.8e"), "\n",],
	record=[:Iterate, rec => :Change],
	return_state=true
    )
end
```

We extract the recorded values

```{julia}
    change = get_record(st_res, :Iteration, :Change)[2:end]
    p_res = get_solver_result(st_res)
```

and plot the result, where we measure the norms of the Newton direction in each iteration,

```{julia}
f = Figure(;)
row, col = fldmod1(1, 2)
Axis(f[row, col], yscale = log10, title = string("Norms of the Newton directions (semilogarithmic)"), xminorgridvisible = true, xticks = (1:length(change)), xlabel = "Iteration", ylabel = "‖δ γ‖")
scatterlines!(change[1:end], color = :blue)
f
```

and the resulting elastic geodesic under the force field (orange).
The starting geodesic (blue) is plotted as well. The force acting on each point of the geodesic is visualized by green arrows.

```{julia}
n = 25
u = range(0; stop=2 * π, length=n);
v = range(0; stop=π, length=n);
sx = zeros(n, n);
sy = zeros(n, n);
sz = zeros(n, n);

ws = [-w(p, integrand.scaling) for p in p_res]
ws_start = [-w(p, integrand.scaling) for p in discretized_y]
for i in 1:n
    for j in 1:n
        sx[i, j] = cos.(u[i]) * sin(v[j])
        sy[i, j] = sin.(u[i]) * sin(v[j])
        sz[i, j] = cos(v[j])
    end
end
fig, ax, plt = meshscatter(
    sx, sy, sz; color=RGBA(1.0, 1.0, 1.0, 0.0), shading=Makie.automatic, transparency=true
)
geodesic_start = [y0, discretized_y..., yT]
geodesic_final = [y0, p_res..., yT]
ax.show_axis = false
wireframe!(ax, sx, sy, sz; color=RGBA(0.5, 0.5, 0.7, 0.1), transparency=true)
π1(x) = 1.02 * x[1]
π2(x) = 1.02 * x[2]
π3(x) = 1.02 * x[3]
scatterlines!(
    ax, π1.(geodesic_final), π2.(geodesic_final), π3.(geodesic_final);
    markersize=5, color=:orange, linewidth=2,
)
scatterlines!(
    ax, π1.(geodesic_start), π2.(geodesic_start), π3.(geodesic_start);
    markersize=5, color=:blue, linewidth=2,
)
scatter!(ax, π1.([y0, yT]), π2.([y0, yT]), π3.([y0, yT]); markersize=5, color=:red)
arrows!(
    ax, π1.(p_res), π2.(p_res), π3.(p_res), π1.(ws), π2.(ws), π3.(ws);
    color=:green, linewidth=0.01,
    arrowsize=Vec3f(0.03, 0.03, 0.05), transparency=true, lengthscale=0.07,
)
cam = cameracontrols(ax.scene); cam.lookat[] = [-2.5, 2.5, 2]
fig
```



## Technical details

This tutorial is cached. It was last run on the following package versions.

```{julia}
#| code-fold: true
using Pkg
Pkg.status()
```
```{julia}
#| code-fold: true
using Dates
now()
```

## Literature

````{=commonmark}
```@bibliography
Pages = ["Elastic-Geodesic-under-forcefield.md"]
Canonical=false
```
````