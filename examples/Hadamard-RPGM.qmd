---
title: "A comparison of the RPGM with the CPPA on Hadamard manifolds"
author: "Hajg Jasa"
date: 03/18/2025
---

## Introduction

In this example we compare the Riemannian Proximal Gradient Method (RPGM) [BergmannJasaJohnPfeffer:2025](@cite) with the Cyclic Proximal Point Algorithm, which was introduced in [Bacak:2014](@cite), on the space of symmetric positive definite matrices and on hyperbolic space.
This example reproduces the results from [BergmannJasaJohnPfeffer:2025](@cite), Section 6.

```{julia}
#| echo: false
#| code-fold: true
#| output: false
using Pkg;
cd(@__DIR__)
Pkg.activate("."); # for reproducibility use the local tutorial environment.

Pkg.develop(path="../") # a trick to work on the local dev version

export_orig = true
export_table = true
export_result = true
benchmarking = true

experiment_name = ""
results_folder = joinpath(@__DIR__, experiment_name)
!isdir(results_folder) && mkdir(results_folder)
```

```{julia}
#| output: false
using PrettyTables
using BenchmarkTools
using CSV, DataFrames
using ColorSchemes, Plots
using QuadraticModels, RipQP
using Random, LinearAlgebra, LRUCache
using ManifoldDiff, Manifolds, Manopt, ManoptExamples
```

## The Problem

Let $\mathcal M$ be a Hadamard manifold and $\{q_1,\ldots,q_N\} \in \mathcal M$ denote $N = 1000$
Gaussian random data points.
Let $g \colon \mathcal M \to \mathbb R$ be defined by

```math
g(p) = \sum_{j = 1}^N w_j \, \mathrm{dist}(p, q_j)^2,
```

where $w_j$, $j = 1, \ldots, N$ are positive weights such that $\sum_{j = 1}^N w_j = 1$.
In our experiments, we choose the weights $w_j = \frac{1}{2N}$.
Observe that the function $g$ is strongly convex with respect to the Riemannian metric on $\mathcal M$.
The Riemannian geometric median $p^*$ of the dataset $\{q_1,\ldots,q_N\}$

```math
\mathcal D = \{
    q_1,\ldots,q_N \, \vert \, q_j \in \mathcal M\text{ for all } j = 1,\ldots,N
\}
```

is then defined as

```math
    p^* \coloneqq \operatorname*{arg\,min}_{p \in \mathcal M} g(p),
```

where equality is justified since $p^*$ is uniquely determined on Hadamard manifolds. 

Let now $\bar q \in \cM$ be a given point, and let $h \colon \mathcal M \to \mathbb R$ be defined by

```math
h(p) = \alpha \mathrm{dist}(p, \bar q).
``` 

We define our total objective function as $f = g + h$.
Notice that this objective function is strongly convex with respect to the Riemannian metric on $\mathcal M$ thanks to $g$.
The goal is to find the minimizer of $f$ on $\mathcal M$, which heuristically is an interpolation between the geometric median $p^*$ and $\bar q$.


## Numerical Experiment

We initialize the experiment parameters, as well as some utility functions.
```{julia}
#| output: false
Random.seed!(100)
experiment_name = "Hadamard-RPGM"
results_folder = joinpath(@__DIR__, experiment_name)
!isdir(results_folder) && mkdir(results_folder)

atol = 1e-8
initial_stepsize = 1.5 # initial stepsize for the proximal gradient method backtracking
N = 1000 # number of data points
α = 3/2N # weight for the mean component (h)
hn_dims = [1, 2, 5, 10, 15]
spd_dims = [2, 5, 10, 15]
```

```{julia}
#| output: false
# Objective, gradient, and proxes
g(M, p, data) = 1/2length(data) * sum(distance.(Ref(M), data, Ref(p)).^2)
h(M, p, q) = α * distance(M, p, q)
f(M, p, data, q) = g(M, p, data) + h(M, p, q)
grad_g(M, p, data) = 1/length(data) * sum(ManifoldDiff.grad_distance.(Ref(M), data, Ref(p), 2))
# CPPA needs the proximal operators for g
function proxes_g(M, λ, p, data, q)
    proxes = Function[(M, λ, p, data) -> ManifoldDiff.prox_distance(M, λ / length(data), di, p, 2) for di in data]
    push!(proxes, (M, λ, p, q) -> ManifoldDiff.prox_distance(M, α * λ, q, p, 1))
    return proxes
end
prox_h(M, λ, p, q) = ManifoldDiff.prox_distance(M, α * λ, q, p, 1)
```

We introduce some keyword arguments for the solvers we will use in this experiment
```{julia}
#| output: false
pgm_kwargs = [
    :count => [:Cost, :Gradient],
    :cache => (:LRU, [:Cost, :Gradient], 50),
    :debug => [
        :Iteration,
        (:Cost, "F(p): %1.16f "),
        " ", 
        (:Change, " last change: %1.8f "),
        (:last_stepsize, " last step size: %1.8f "),
        100, 
        :Stop,
        "\n", 
    ],
    :record => [:Iteration, :Cost, :Iterate],
    :return_state => true,
    :stepsize => ProxGradBacktracking(; strategy=:convex, initial_stepsize=initial_stepsize),
    :stopping_criterion => StopWhenAny(
        StopWhenGradientMappingNormLess(atol), StopAfterIteration(max_iters)
    ),
]
pgm_bm_kwargs = [
    :cache => (:LRU, [:Cost, :Gradient], 50),
    :stopping_criterion => StopWhenAny(
        StopWhenGradientMappingNormLess(atol), StopAfterIteration(max_iters)
    ), 
]

cppa_kwargs(M) = [
    :debug => [
        :Iteration,
        " | ",
        DebugProximalParameter(),
        " | ",
        (:Cost, "F(p): %1.16f "),
        " | ",
        :Change,
        "\n",
        1000,
        :Stop,
    ],
    :record => [:Iteration, :Cost, :Iterate],
    :return_state => true,
    :stopping_criterion => StopWhenAny(
        StopAfterIteration(max_iters), StopWhenChangeLess(M, atol)
    ),
]
cppa_bm_kwargs(M) = [
    :stopping_criterion => StopWhenAny(
        StopAfterIteration(max_iters), StopWhenChangeLess(M, atol)
    ),
]
```

Before running the experiments, we initialize data collection functions that we will use later
```{julia}
#| output: false
global col_names_1 = [
    :Dimension,
    :Iterations_1,
    :Time_1,
    :Objective_1,
    :Iterations_2,
    :Time_2,
    :Objective_2,
]
col_types_1 = [
    Int64,
    Int64,
    Float64,
    Float64,
    Int64,
    Float64,
    Float64,
]
named_tuple_1 = (; zip(col_names_1, type[] for type in col_types_1 )...)
global col_names_2 = [
    :Dimension,
    :Iterations,
    :Time,
    :Objective,
]
col_types_2 = [
    Int64,
    Int64,
    Float64,
    Float64,
]
named_tuple_2 = (; zip(col_names_2, type[] for type in col_types_2 )...)
function initialize_dataframes(results_folder, experiment_name, subexperiment_name, named_tuple_1, named_tuple_2)
    A1 = DataFrame(named_tuple_1)
    CSV.write(
        joinpath(
            results_folder,
            experiment_name * "_$subexperiment_name" * "-Comparisons-Convex-Prox.csv",
        ),
        A1;
        header=false,
    )
    A2 = DataFrame(named_tuple_2)
    CSV.write(
        joinpath(
            results_folder,
            experiment_name * "_$subexperiment_name" * "-Comparisons-Subgrad.csv",
        ),
        A2;
        header=false,
    )
    return A1, A2
end
```

```{julia}
#| output: false
function export_dataframes(M, records, times, results_folder, experiment_name, subexperiment_name, col_names_1, col_names_2)
    B1 = DataFrame(;
        Dimension=manifold_dimension(M),
        Iterations_1=maximum(first.(records[1])),
        Time_1=times[1],
        Objective_1=minimum([r[2] for r in records[1]]),
        Iterations_2=maximum(first.(records[2])),
        Time_2=times[2],
        Objective_2=minimum([r[2] for r in records[2]]),
    )
    B2 = DataFrame(;
        Dimension=manifold_dimension(M),
        Iterations=maximum(first.(records[3])),
        Time=times[3],
        Objective=minimum([r[2] for r in records[3]]),
    )
    return B1, B2
end
function write_dataframes(B1, B2, results_folder, experiment_name, subexperiment_name)
    CSV.write(
        joinpath(
            results_folder,
            experiment_name *
            "_$subexperiment_name" *
            "-Comparisons-Convex-Prox.csv",
        ),
        B1;
        append=true,
    )
    CSV.write(
        joinpath(
            results_folder,
            experiment_name *
            "_$subexperiment_name" *
            "-Comparisons-Subgrad.csv",
        ),
        B2;
        append=true,
    )
end
```

## On Hyperbolic Space
```{julia}
#| output: false
subexperiment_name = "Hn"
global A1, A2 = initialize_dataframes(
    results_folder,
    experiment_name,
    subexperiment_name,
    named_tuple_1,
    named_tuple_2
)

for n in hn_dims

    M = Hyperbolic(Int(2^n))
    data = [rand(M) for _ in 1:N]
    q = rand(M) # we can artificially craft a point for the mean component, i.e. h
    p0 = rand(M) #data[minimum(Tuple(findmax(dists)[2]))]

    g_hn(M, p) = g(M, p, data)
    # h_hn(M, p) = h(M, p, q)
    grad_g_hn(M, p) = grad_g(M, p, data)
    proxes_g_hn(M, λ, p) = proxes_g(M, λ, p, data, q)
    prox_h_hn(M, λ, p) = prox_h(M, λ, p, q)
    f_hn(M, p) = f(M, p, data, q)

    # Optimization
    pgm = proximal_gradient_method(M, f_hn, g_hn, grad_g_hn, prox_h_hn, p0; pgm_kwargs...)
    pgm_result = get_solver_result(pgm)
    pgm_record = get_record(pgm)

    cppa = cyclic_proximal_point(M, f_hn, proxes_g_hn, p0; cppa_kwargs(M)...)
    cppa_result = get_solver_result(cppa)
    cppa_record = get_record(cppa)

    records = [
        pgm_record,
        cppa_record,
    ]

    if benchmarking
        pgm_bm = @benchmark proximal_gradient_method($M, $f_hn, $g_hn, $grad_g_hn, $prox_h_hn, $p0; $pgm_bm_kwargs...)
        cppa_bm = @benchmark cyclic_proximal_point($M, $f_hn, $proxes_g_hn, $p0; cppa_bm_kwargs($M)...)
        
        times = [
            median(pgm_bm).time * 1e-9,
            median(cppa_bm).time * 1e-9,
        ]

        B1, B2 = export_dataframes(
            M,
            records,
            times,
            results_folder,
            experiment_name,
            subexperiment_name,
            col_names_1,
            col_names_2,
        )

        append!(A1, B1)
        append!(A2, B2)
        (export_table) && (write_dataframes(B1, B2, results_folder, experiment_name, subexperiment_name))
    end
end
```
We can take a look at how the algorithms compare to each other in their performance with the following table, where columns 2 to 4 relate to the RCBM, while columns 5 to 7 refer to the PBA...
```{julia}
#| echo: false
#| code-fold: true
benchmarking && pretty_table(A1, tf = tf_markdown, header=col_names_1)
```
... Whereas the following table refers to the SGM
```{julia}
#| echo: false
#| code-fold: true
benchmarking && pretty_table(A2, tf = tf_markdown, header=col_names_2)
```


## The Median on the Symmetric Positive Definite Matrix Space
```{julia}
#| output: false
subexperiment_name = "SPD"
k_max_spd = 0.0
diameter_spd = floatmax(Float64)
global A1_SPD, A2_SPD = initialize_dataframes(
    results_folder,
    experiment_name,
    subexperiment_name,
    named_tuple_1,
    named_tuple_2
)

for n in spd_dims

    M = SymmetricPositiveDefinite(Int(n))
    data = [rand(M) for _ in 1:N]
    q = rand(M) # we can artificially craft a point for the mean component, i.e. h
    p0 = rand(M) #data[minimum(Tuple(findmax(dists)[2]))]

    g_spd(M, p) = g(M, p, data)
    # h_spd(M, p) = h(M, p, q)
    grad_g_spd(M, p) = grad_g(M, p, data)
    proxes_g_spd(M, λ, p) = proxes_g(M, λ, p, data, q)
    prox_h_spd(M, λ, p) = prox_h(M, λ, p, q)
    f_spd(M, p) = f(M, p, data, q)

    # Optimization
    pgm = proximal_gradient_method(M, f_spd, g_spd, grad_g_spd, prox_h_spd, p0; pgm_kwargs...)
    pgm_result = get_solver_result(pgm)
    pgm_record = get_record(pgm)

    cppa = cyclic_proximal_point(M, f_spd, proxes_g_spd, p0; cppa_kwargs(M)...)
    cppa_result = get_solver_result(cppa)
    cppa_record = get_record(cppa)

    records = [
        pgm_record,
        cppa_record,
    ]

    if benchmarking
        pgm_bm = @benchmark proximal_gradient_method($M, $f_spd, $g_spd, $grad_g_spd, $prox_h_spd, $p0; $pgm_bm_kwargs...)
        cppa_bm = @benchmark cyclic_proximal_point($M, $f_spd, $proxes_g_spd, $p0; cppa_bm_kwargs($M)...)
        
        times = [
            median(pgm_bm).time * 1e-9,
            median(cppa_bm).time * 1e-9,
        ]

        B1, B2 = export_dataframes(
            M,
            records,
            times,
            results_folder,
            experiment_name,
            subexperiment_name,
            col_names_1,
            col_names_2,
        )

        append!(A1, B1)
        append!(A2, B2)
        (export_table) && (write_dataframes(B1, B2, results_folder, experiment_name, subexperiment_name))
    end
end
```

We can take a look at how the algorithms compare to each other in their performance with the following table, where columns 2 to 4 relate to the RCBM, while columns 5 to 7 refer to the PBA...
```{julia}
#| echo: false
#| code-fold: true
benchmarking && pretty_table(A1_SPD, tf = tf_markdown, header=col_names_1)
```

... Whereas the following table refers to the SGM
```{julia}
#| echo: false
#| code-fold: true
benchmarking && pretty_table(A2_SPD, tf = tf_markdown, header=col_names_2)
```

## Literature

````{=commonmark}
```@bibliography
Pages = ["Hadamard-RPGM.md"]
Canonical=false
```
````