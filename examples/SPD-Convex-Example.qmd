---
title: "Proximal Gradient Method: A Geodesically Convex Example on SPDs"
author: "Hajg Jasa"
date: 04/16/2025
engine: julia
---

## Introduction

In this example we compare the Convex Riemannian Proximal Gradient (CRPG) method [BergmannJasaJohnPfeffer:2025:2](@cite) with the Cyclic Proximal Point Algorithm, which was introduced in [Bacak:2014](@cite), on the space of symmetric positive definite matrices.
This example reproduces the results from [BergmannJasaJohnPfeffer:2025:2](@cite), Section 5.3.

```{julia}
#| echo: false
#| code-fold: true
#| output: false
using Pkg;
cd(@__DIR__)
Pkg.activate("."); # for reproducibility use the local tutorial environment.

Pkg.develop(path="../") # a trick to work on the local dev version

export_orig = true
export_table = true
export_result = true
benchmarking = true

experiment_name = ""
results_folder = joinpath(@__DIR__, experiment_name)
!isdir(results_folder) && mkdir(results_folder)
```

```{julia}
#| output: false
using PrettyTables
using BenchmarkTools
using CSV, DataFrames
using ColorSchemes, Plots
using Random, LinearAlgebra, LRUCache
using ManifoldDiff, Manifolds, Manopt, ManoptExamples
```

## The Problem

Let $\mathcal M = \mathcal H^2$ be the $2$-dimensional hyperbolic space.

Let $g \colon \mathcal M \to \mathbb R$ be defined by

```math
g(p) = \log(\det(p))^4.
```

Observe that the function $g$ is geodesically convex with respect to the Riemannian metric on $\mathcal M$.

Let now $q_1 \neq q_1$ be a given point, and let $h \colon \mathcal M \to \mathbb R$ be defined by

```math
h(p) = \tau \mathrm{dist}(p, q_1),
```

for some $\tau > 0$.
We define our total objective function as $f = g + h$.
Notice that this objective function is also geodesically convex with respect to the Riemannian metric on $\mathcal M$.
The goal is to find the minimizer of $f$ on $\mathcal M$, which is an interpolation between the two points $q_1$ and $q_1$, depending on the value of $\tau$.
Namely, if $\tau < 1$, the minimizer is $q_1$; if $\tau > 1$, the minimizer is $q_1$; and if $\tau = 1$, the minimizer is the geodesic segment between $q_1$ and $q_1$.


## Numerical Experiment

We initialize the experiment parameters, as well as some utility functions.
```{julia}
#| output: false
random_seed = 42
experiment_name = "SPD-Convex-Example"
results_folder = joinpath(@__DIR__, experiment_name)
!isdir(results_folder) && mkdir(results_folder)

atol = 1e-6
max_iters = 15000
τ = 1/2 # weight for the component h
spd_dims = [2]#, 3, 4, 5]
```

```{julia}
#| output: false
# Objective, gradient, and proxes
g(M, p) = log(det(p))^4
grad_g(M, p) = 4log(det(p))^3 * p
# 
h(M, p, q) = τ * distance(M, p, q)
prox_h(M, λ, p, q) = ManifoldDiff.prox_distance(M, τ * λ, q, p, 1)
# 
f(M, p, q) = g(M, p) + h(M, p, q)
# CPPA needs the proximal operators for the total objective
# function proxes_f(data, q)
#     proxes = Function[(M, λ, p) -> ManifoldDiff.prox_distance(M, λ / length(data), di, p, 2) for di in data]
#     push!(proxes, (M, λ, p) -> ManifoldDiff.prox_distance(M, α * λ, q, p, 1))
#     return proxes
# end
```

We introduce some keyword arguments for the solvers we will use in this experiment
```{julia}
#| output: false
pgm_kwargs(initial_stepsize) = [
    :record => [:Iteration, :Cost, :Iterate],
    :return_state => true,
    :stepsize => ProxGradBacktracking(; strategy=:convex, initial_stepsize=initial_stepsize),
    :stopping_criterion => StopWhenAny(
        StopWhenGradientMappingNormLess(atol), StopAfterIteration(max_iters)
    ),
]
pgm_bm_kwargs(initial_stepsize) = [
    :stepsize => ProxGradBacktracking(; strategy=:convex, initial_stepsize=initial_stepsize),
    :stopping_criterion => StopWhenAny(
        StopWhenGradientMappingNormLess(atol), StopAfterIteration(max_iters)
    ), 
]

# cppa_kwargs(M) = [
#     :record => [:Iteration, :Cost, :Iterate],
#     :return_state => true,
#     :stopping_criterion => StopWhenAny(
#         StopAfterIteration(max_iters), StopWhenChangeLess(M, atol)
#     ),
# ]
# cppa_bm_kwargs(M) = [
#     :stopping_criterion => StopWhenAny(
#         StopAfterIteration(max_iters), StopWhenChangeLess(M, atol)
#     ),
# ]
```

Before running the experiments, we initialize data collection functions that we will use later
```{julia}
#| output: false
global col_names_1 = [
    :Dimension,
    :Iterations_1,
    :Time_1,
    :Objective_1,
    # :Iterations_2,
    # :Time_2,
    # :Objective_2,
]
col_types_1 = [
    Int64,
    Float64,
    Float64,
    Float64,
    # Int64,
    # Float64,
    # Float64,
]
named_tuple_1 = (; zip(col_names_1, type[] for type in col_types_1 )...)
global col_names_2 = [
    :Dimension,
    :Iterations,
    :Time,
    :Objective,
]
col_types_2 = [
    Int64,
    Float64,
    Float64,
    Float64,
]
named_tuple_2 = (; zip(col_names_2, type[] for type in col_types_2 )...)
function initialize_dataframes(results_folder, experiment_name, subexperiment_name, named_tuple_1, named_tuple_2)
    A1 = DataFrame(named_tuple_1)
    CSV.write(
        joinpath(
            results_folder,
            experiment_name * "_$subexperiment_name" * "-Comparisons.csv",
        ),
        A1;
        header=false,
    )
    # A2 = DataFrame(named_tuple_2)
    # CSV.write(
    #     joinpath(
    #         results_folder,
    #         experiment_name * "_$subexperiment_name" * "-Comparisons-Subgrad.csv",
    #     ),
    #     A2;
    #     header=false,
    # )
    return A1#, A2
end
```

```{julia}
#| output: false
function export_dataframes(M, records, times, results_folder, experiment_name, subexperiment_name, col_names_1, col_names_2)
    B1 = DataFrame(;
        Dimension=manifold_dimension(M),
        Iterations_1=mean(first.(records[1])),
        Time_1=times[1],
        Objective_1=minimum([r[2] for r in records[1]]),
        # Iterations_2=maximum(first.(records[2])),
        # Time_2=times[2],
        # Objective_2=minimum([r[2] for r in records[2]]),
    )
    # B2 = DataFrame(;
    #     Dimension=manifold_dimension(M),
    #     Iterations=maximum(first.(records[3])),
    #     Time=times[3],
    #     Objective=minimum([r[2] for r in records[3]]),
    # )
    return B1#, B2
end
function write_dataframes(
    B1, 
    # B2, 
    results_folder, 
    experiment_name, 
    subexperiment_name
)
    CSV.write(
        joinpath(
            results_folder,
            experiment_name *
            "_$subexperiment_name" *
            "-Comparisons.csv",
            # -Convex-Prox.csv",
        ),
        B1;
        append=true,
    )
    # CSV.write(
    #     joinpath(
    #         results_folder,
    #         experiment_name *
    #         "_$subexperiment_name" *
    #         "-Comparisons-Subgrad.csv",
    #     ),
    #     B2;
    #     append=true,
    # )
end
```

```{julia}
#| output: false
# Function to generate points close to the given point p
function close_point(M, p, tol; retraction_method=Manifolds.default_retraction_method(M, typeof(p)))
    X = rand(M; vector_at = p)
    X .= tol * rand() * X / norm(M, p, X)
    return retract(M, p, X, retraction_method)
end
# Estimate Lipschitz constant of the gradient of g
function estimate_lipschitz_constant(M, g, anchor, R=D, N=100_000)
    constants = []
    for i in 1:N
        p = rand(M)# close_point(M, anchor, R)
        q = rand(M) #close_point(M, anchor, R)

        push!(constants, 2/distance(M, q, p)^2 * (g(M, q) - g(M, p) - inner(M, p, grad_g(M, p), log(M, p, q))))
    end
    return maximum(constants)
end
```

```{julia}
subexperiment_name = "SPD"
k_max_spd = 0.0
global A1_SPD = initialize_dataframes(
    results_folder,
    experiment_name,
    subexperiment_name,
    named_tuple_1,
    named_tuple_2
)

for n in spd_dims

    Random.seed!(random_seed)

    M = SymmetricPositiveDefinite(Int(n))
    q = rand(M) # we can artificially craft a point for the median component, i.e. h
    p0 = rand(M) #data[minimum(Tuple(findmax(dists)[2]))]

    prox_h_spd(M, λ, p) = prox_h(M, λ, p, q)
    f_spd(M, p) = f(M, p, q)

    D = 4*distance(M, p0, q)
    # Coseravative estimate of the Lipschitz constant for grad_g
    L_g = 3/2 * estimate_lipschitz_constant(M, g, p0, D)
    initial_stepsize = 1/L_g
    println(initial_stepsize)

    # Optimization
    pgm = proximal_gradient_method(M, f_spd, g, grad_g, prox_h_spd, p0; pgm_kwargs(initial_stepsize)...)
    pgm_result = get_solver_result(pgm)
    pgm_record = get_record(pgm)

    # cppa = cyclic_proximal_point(M, f_spd, proxes_f_spd, p0; cppa_kwargs(M)...)
    # cppa_result = get_solver_result(cppa)
    # cppa_record = get_record(cppa)

    records = [
        pgm_record,
        # cppa_record,
    ]

    if benchmarking
        pgm_bm = @benchmark proximal_gradient_method($M, $f_spd, $g, $grad_g, $prox_h_spd, $p0; $pgm_bm_kwargs($initial_stepsize)...)
        # cppa_bm = @benchmark cyclic_proximal_point($M, $f_spd, $proxes_f_spd, $p0; cppa_bm_kwargs($M)...)
        
        times = [
            median(pgm_bm).time * 1e-9,
            # median(cppa_bm).time * 1e-9,
        ]

        B1 = export_dataframes(
            M,
            records,
            times,
            results_folder,
            experiment_name,
            subexperiment_name,
            col_names_1,
            col_names_2,
        )

        append!(A1_SPD, B1)
        # append!(A2_SPD, B2)
        (export_table) && (write_dataframes(B1, results_folder, experiment_name, subexperiment_name))
    end
end
```

We can take a look at how the algorithms compare to each other in their performance with the following table, where columns 2 to 4 relate to CRPG, while columns 5 to 7 refer to the CPPA...
```{julia}
# | echo: false
# | label: tbl-algo
# | tbl-cap: Algorithm performance
benchmarking && pretty_table(A1_SPD; tf = tf_markdown, header = col_names_1)
```

## Technical details

This tutorial is cached. It was last run on the following package versions.

```{julia}
#| code-fold: true
using Pkg
Pkg.status()
```
```{julia}
#| code-fold: true
#| echo: false
#| output: asis
using Dates
println("This tutorial was last rendered $(Dates.format(now(), "U d, Y, H:M:S")).");
```

## Literature

````{=commonmark}
```@bibliography
Pages = ["Hadamard-CRPG.md"]
Canonical=false
```
````